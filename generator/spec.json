{
  "versions": [
    {
      "name": "1.0.2",
      "release_date": "May 1996",
      "major": 45,
      "supported_majors": [
        45
      ]
    },
    {
      "name": "1.1",
      "release_date": "February 1997",
      "major": 45,
      "supported_majors": [
        45
      ]
    },
    {
      "name": "1.2",
      "release_date": "December 1998",
      "major": 46,
      "supported_majors": [
        45,
        46
      ]
    },
    {
      "name": "1.3",
      "release_date": "May 2000",
      "major": 47,
      "supported_majors": [
        45,
        46,
        47
      ]
    },
    {
      "name": "1.4",
      "release_date": "February 2002",
      "major": 48,
      "supported_majors": [
        45,
        46,
        47,
        48
      ]
    },
    {
      "name": "5.0",
      "release_date": "September 2004",
      "major": 49,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49
      ]
    },
    {
      "name": "6",
      "release_date": "December 2006",
      "major": 50,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50
      ]
    },
    {
      "name": "7",
      "release_date": "July 2011",
      "major": 51,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51
      ]
    },
    {
      "name": "8",
      "release_date": "March 2014",
      "major": 52,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52
      ]
    },
    {
      "name": "9",
      "release_date": "September 2017",
      "major": 53,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53
      ]
    },
    {
      "name": "10",
      "release_date": "March 2018",
      "major": 54,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54
      ]
    },
    {
      "name": "11",
      "release_date": "September 2018",
      "major": 55,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55
      ]
    },
    {
      "name": "12",
      "release_date": "March 2019",
      "major": 56,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56
      ]
    },
    {
      "name": "13",
      "release_date": "September 2019",
      "major": 57,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]
    },
    {
      "name": "14",
      "release_date": "March 2020",
      "major": 58,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58
      ]
    },
    {
      "name": "15",
      "release_date": "September 2020",
      "major": 59,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59
      ]
    },
    {
      "name": "16",
      "release_date": "March 2021",
      "major": 60,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60
      ]
    },
    {
      "name": "17",
      "release_date": "September 2021",
      "major": 61,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61
      ]
    },
    {
      "name": "18",
      "release_date": "March 2022",
      "major": 62,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62
      ]
    },
    {
      "name": "19",
      "release_date": "September 2022",
      "major": 63,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63
      ]
    },
    {
      "name": "20",
      "release_date": "March 2023",
      "major": 64,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64
      ]
    },
    {
      "name": "21",
      "release_date": "September 2023",
      "major": 65,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65
      ]
    },
    {
      "name": "22",
      "release_date": "March 2024",
      "major": 66,
      "supported_majors": [
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66
      ]
    }
  ],
  "pool_tags": [
    {
      "name": "CONSTANT_Utf8",
      "value": 1,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_Integer",
      "value": 3,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_Float",
      "value": 4,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_Long",
      "value": 5,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_Double",
      "value": 6,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_Class",
      "value": 7,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_String",
      "value": 8,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_Fieldref",
      "value": 9,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_Methodref",
      "value": 10,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_InterfaceMethodref",
      "value": 11,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_NameAndType",
      "value": 12,
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "CONSTANT_MethodHandle",
      "value": 15,
      "version": {
        "major": 51,
        "minor": 0,
        "java": "7"
      }
    },
    {
      "name": "CONSTANT_MethodType",
      "value": 16,
      "version": {
        "major": 51,
        "minor": 0,
        "java": "7"
      }
    },
    {
      "name": "CONSTANT_Dynamic",
      "value": 17,
      "version": {
        "major": 55,
        "minor": 0,
        "java": "11"
      }
    },
    {
      "name": "CONSTANT_InvokeDynamic",
      "value": 18,
      "version": {
        "major": 51,
        "minor": 0,
        "java": "7"
      }
    },
    {
      "name": "CONSTANT_Module",
      "value": 19,
      "version": {
        "major": 53,
        "minor": 0,
        "java": "9"
      }
    },
    {
      "name": "CONSTANT_Package",
      "value": 20,
      "version": {
        "major": 53,
        "minor": 0,
        "java": "9"
      }
    }
  ],
  "pool_handle_kinds": [
    {
      "value": 1,
      "name": "REF_getField",
      "interpretation": "getfield C.f:T"
    },
    {
      "value": 2,
      "name": "REF_getStatic",
      "interpretation": "getstatic C.f:T"
    },
    {
      "value": 3,
      "name": "REF_putField",
      "interpretation": "putfield C.f:T"
    },
    {
      "value": 4,
      "name": "REF_putStatic",
      "interpretation": "putstatic C.f:T"
    },
    {
      "value": 5,
      "name": "REF_invokeVirtual",
      "interpretation": "invokevirtual C.m:(A*)T"
    },
    {
      "value": 6,
      "name": "REF_invokeStatic",
      "interpretation": "invokestatic C.m:(A*)T"
    },
    {
      "value": 7,
      "name": "REF_invokeSpecial",
      "interpretation": "invokespecial C.m:(A*)T"
    },
    {
      "value": 8,
      "name": "REF_newInvokeSpecial",
      "interpretation": "new C; dup; invokespecial C.<init>:(A*)V"
    },
    {
      "value": 9,
      "name": "REF_invokeInterface",
      "interpretation": "invokeinterface C.m:(A*)T"
    }
  ],
  "attributes": [
    {
      "name": "ConstantValue",
      "section": "\u00a74.7.2",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "Code",
      "section": "\u00a74.7.3",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "StackMapTable",
      "section": "\u00a74.7.4",
      "version": {
        "major": 50,
        "minor": 0,
        "java": "6"
      }
    },
    {
      "name": "Exceptions",
      "section": "\u00a74.7.5",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "InnerClasses",
      "section": "\u00a74.7.6",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.1"
      }
    },
    {
      "name": "EnclosingMethod",
      "section": "\u00a74.7.7",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "Synthetic",
      "section": "\u00a74.7.8",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.1"
      }
    },
    {
      "name": "Signature",
      "section": "\u00a74.7.9",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "SourceFile",
      "section": "\u00a74.7.10",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "SourceDebugExtension",
      "section": "\u00a74.7.11",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "LineNumberTable",
      "section": "\u00a74.7.12",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "LocalVariableTable",
      "section": "\u00a74.7.13",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.0.2"
      }
    },
    {
      "name": "LocalVariableTypeTable",
      "section": "\u00a74.7.14",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "Deprecated",
      "section": "\u00a74.7.15",
      "version": {
        "major": 45,
        "minor": 3,
        "java": "1.1"
      }
    },
    {
      "name": "RuntimeVisibleAnnotations",
      "section": "\u00a74.7.16",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "RuntimeInvisibleAnnotations",
      "section": "\u00a74.7.17",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "RuntimeVisibleParameterAnnotations",
      "section": "\u00a74.7.18",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "RuntimeInvisibleParameterAnnotations",
      "section": "\u00a74.7.19",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "RuntimeVisibleTypeAnnotations",
      "section": "\u00a74.7.20",
      "version": {
        "major": 52,
        "minor": 0,
        "java": "8"
      }
    },
    {
      "name": "RuntimeInvisibleTypeAnnotations",
      "section": "\u00a74.7.21",
      "version": {
        "major": 52,
        "minor": 0,
        "java": "8"
      }
    },
    {
      "name": "AnnotationDefault",
      "section": "\u00a74.7.22",
      "version": {
        "major": 49,
        "minor": 0,
        "java": "5.0"
      }
    },
    {
      "name": "BootstrapMethods",
      "section": "\u00a74.7.23",
      "version": {
        "major": 51,
        "minor": 0,
        "java": "7"
      }
    },
    {
      "name": "MethodParameters",
      "section": "\u00a74.7.24",
      "version": {
        "major": 52,
        "minor": 0,
        "java": "8"
      }
    },
    {
      "name": "Module",
      "section": "\u00a74.7.25",
      "version": {
        "major": 53,
        "minor": 0,
        "java": "9"
      }
    },
    {
      "name": "ModulePackages",
      "section": "\u00a74.7.26",
      "version": {
        "major": 53,
        "minor": 0,
        "java": "9"
      }
    },
    {
      "name": "ModuleMainClass",
      "section": "\u00a74.7.27",
      "version": {
        "major": 53,
        "minor": 0,
        "java": "9"
      }
    },
    {
      "name": "NestHost",
      "section": "\u00a74.7.28",
      "version": {
        "major": 55,
        "minor": 0,
        "java": "11"
      }
    },
    {
      "name": "NestMembers",
      "section": "\u00a74.7.29",
      "version": {
        "major": 55,
        "minor": 0,
        "java": "11"
      }
    },
    {
      "name": "Record",
      "section": "\u00a74.7.30",
      "version": {
        "major": 60,
        "minor": 0,
        "java": "16"
      }
    },
    {
      "name": "PermittedSubclasses",
      "section": "\u00a74.7.31",
      "version": {
        "major": 61,
        "minor": 0,
        "java": "17"
      }
    }
  ],
  "access_flags": [
    {
      "name": "ACC_PUBLIC",
      "value": 1,
      "descriptions": {
        "class": "Declared public; may be accessed from outside its package.",
        "field": "Declared public; may be accessed from outside its package.",
        "method": "Declared public; may be accessed from outside its package."
      }
    },
    {
      "name": "ACC_FINAL",
      "value": 16,
      "descriptions": {
        "class": "Declared final; no subclasses allowed.",
        "field": "Declared final; never directly assigned to after object construction (JLS \u00a717.5).",
        "method": "Declared final; must not be overridden (\u00a75.4.5)."
      }
    },
    {
      "name": "ACC_SUPER",
      "value": 32,
      "descriptions": {
        "class": "Treat superclass methods specially when invoked by the invokespecial instruction."
      }
    },
    {
      "name": "ACC_INTERFACE",
      "value": 512,
      "descriptions": {
        "class": "Is an interface, not a class."
      }
    },
    {
      "name": "ACC_ABSTRACT",
      "value": 1024,
      "descriptions": {
        "class": "Declared abstract; must not be instantiated.",
        "method": "Declared abstract; no implementation is provided."
      }
    },
    {
      "name": "ACC_SYNTHETIC",
      "value": 4096,
      "descriptions": {
        "class": "Declared synthetic; not present in the source code.",
        "field": "Declared synthetic; not present in the source code.",
        "method": "Declared synthetic; not present in the source code."
      }
    },
    {
      "name": "ACC_ANNOTATION",
      "value": 8192,
      "descriptions": {
        "class": "Declared as an annotation interface."
      }
    },
    {
      "name": "ACC_ENUM",
      "value": 16384,
      "descriptions": {
        "class": "Declared as an enum class.",
        "field": "Declared as an element of an enum class."
      }
    },
    {
      "name": "ACC_MODULE",
      "value": 32768,
      "descriptions": {
        "class": "Is a module, not a class or interface."
      }
    },
    {
      "name": "ACC_PRIVATE",
      "value": 2,
      "descriptions": {
        "field": "Declared private; accessible only within the\ndefining class and other classes belonging to the\nsame nest (\u00a75.4.4).",
        "method": "Declared private; accessible only within the\ndefining class and other classes belonging to the\nsame nest (\u00a75.4.4)."
      }
    },
    {
      "name": "ACC_PROTECTED",
      "value": 4,
      "descriptions": {
        "field": "Declared protected; may be accessed within subclasses.",
        "method": "Declared protected; may be accessed within subclasses."
      }
    },
    {
      "name": "ACC_STATIC",
      "value": 8,
      "descriptions": {
        "field": "Declared static.",
        "method": "Declared static."
      }
    },
    {
      "name": "ACC_VOLATILE",
      "value": 64,
      "descriptions": {
        "field": "Declared volatile; cannot be cached."
      }
    },
    {
      "name": "ACC_TRANSIENT",
      "value": 128,
      "descriptions": {
        "field": "Declared transient; not written or read by a persistent object manager."
      }
    },
    {
      "name": "ACC_SYNCHRONIZED",
      "value": 32,
      "descriptions": {
        "method": "Declared synchronized; invocation is wrapped by a monitor use."
      }
    },
    {
      "name": "ACC_BRIDGE",
      "value": 64,
      "descriptions": {
        "method": "A bridge method, generated by the compiler."
      }
    },
    {
      "name": "ACC_VARARGS",
      "value": 128,
      "descriptions": {
        "method": "Declared with variable number of arguments."
      }
    },
    {
      "name": "ACC_NATIVE",
      "value": 256,
      "descriptions": {
        "method": "Declared native; implemented in a language other than the Java programming language."
      }
    },
    {
      "name": "ACC_STRICT",
      "value": 2048,
      "descriptions": {
        "method": "In a class file whose major version number is at least 46 and at most 60: Declared strictfp."
      }
    }
  ],
  "insns": [
    {
      "name": "aaload",
      "operation": "Load reference from array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "aaload",
          "value": 50
        }
      ],
      "stack": "..., arrayref, index \u2192 ..., value",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type reference. The index must be of type\nint. Both arrayref and index are popped from the operand\nstack. The reference value in the component of the array at index\nis retrieved and pushed onto the operand stack."
    },
    {
      "name": "aastore",
      "operation": "Store into reference array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "aastore",
          "value": 83
        }
      ],
      "stack": "..., arrayref, index, value \u2192 ...",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type reference. The index must be of type\nint, and value must be of type reference. The arrayref, index,\nand value are popped from the operand stack.\nIf value is null, then value is stored as the component of\nthe array at index.\nOtherwise, value is non-null. If the type of value is\nassignment compatible with the type of the components of the array\nreferenced by arrayref, then value is stored as the component\nof the array at index.\nThe following rules are used to determine whether a value that\nis not null is assignment compatible with the array component\ntype. If S is the type of the object referred to by value, and\nT is the reference type of the array components, then aastore\ndetermines whether assignment is compatible as follows:\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC is\nassignable to TC by these run-time rules.\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC is\nassignable to TC by these run-time rules.\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC is\nassignable to TC by these run-time rules.\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC is\nassignable to TC by these run-time rules.\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC is\nassignable to TC by these run-time rules.\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC is\nassignable to TC by these run-time rules.\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC is\nassignable to TC by these run-time rules."
    },
    {
      "name": "aconst_null",
      "operation": "Push null",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "aconst_null",
          "value": 1
        }
      ],
      "stack": "... \u2192 ..., null",
      "description": "Push the null object reference onto the operand stack."
    },
    {
      "name": "aload",
      "operation": "Load reference from local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "aload",
          "value": 25
        }
      ],
      "stack": "... \u2192 ..., objectref",
      "description": "The index is an unsigned byte that must be an index into the\nlocal variable array of the current frame\n(\u00a72.6). The local variable at index must\ncontain a reference. The objectref in the local variable at index\nis pushed onto the operand stack."
    },
    {
      "name": "aload_<n>",
      "operation": "Load reference from local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "aload_0",
          "value": 42
        },
        {
          "name": "aload_1",
          "value": 43
        },
        {
          "name": "aload_2",
          "value": 44
        },
        {
          "name": "aload_3",
          "value": 45
        }
      ],
      "stack": "... \u2192 ..., objectref",
      "description": "The <n> must be an index into the local variable array\nof the current frame (\u00a72.6). The local\nvariable at <n> must contain a reference. The objectref\nin the local variable at <n> is pushed onto the operand\nstack."
    },
    {
      "name": "anewarray",
      "operation": "Create new array of reference",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "anewarray",
          "value": 189
        }
      ],
      "stack": "..., count \u2192 ..., arrayref",
      "description": "The count must be of type int. It is popped off the operand\nstack. The count represents the number of components of the\narray to be created. The unsigned indexbyte1 and indexbyte2\nare used to construct an index into the run-time constant pool of\nthe current class (\u00a72.6), where the value of\nthe index is (indexbyte1 << 8) | indexbyte2. The\nrun-time constant pool entry at the index must be a symbolic\nreference to a class, array, or interface type. The named class,\narray, or interface type is resolved\n(\u00a75.4.3.1). A new array with components of\nthat type, of length count, is allocated from the\ngarbage-collected heap, and a reference arrayref to this new array\nobject is pushed onto the operand stack. All components of the new\narray are initialized to null, the default value for reference types\n(\u00a72.4)."
    },
    {
      "name": "areturn",
      "operation": "Return reference from method",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "areturn",
          "value": 176
        }
      ],
      "stack": "..., objectref \u2192 [empty]",
      "description": "The objectref must be of type reference and must refer to an object\nof a type that is assignment compatible (JLS \u00a75.2) with the type\nrepresented by the return descriptor\n(\u00a74.3.3) of the current method. If the\ncurrent method is a synchronized method, the monitor entered or\nreentered on invocation of the method is updated and possibly\nexited as if by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current thread. If\nno exception is thrown, objectref is popped from the operand\nstack of the current frame (\u00a72.6) and pushed\nonto the operand stack of the frame of the invoker. Any other\nvalues on the operand stack of the current method are\ndiscarded.\nThe interpreter then reinstates the frame of the invoker and\nreturns control to the invoker."
    },
    {
      "name": "arraylength",
      "operation": "Get length of array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "arraylength",
          "value": 190
        }
      ],
      "stack": "..., arrayref \u2192 ..., length",
      "description": "The arrayref must be of type reference and must refer to an\narray. It is popped from the operand\nstack. The length of the array it references\nis determined. That length is pushed onto the\noperand stack as an int."
    },
    {
      "name": "astore",
      "operation": "Store reference into local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "astore",
          "value": 58
        }
      ],
      "stack": "..., objectref \u2192 ...",
      "description": "The index is an unsigned byte that must be an index into the\nlocal variable array of the current frame\n(\u00a72.6). The objectref on the top of the\noperand stack must be of type returnAddress or of type reference. It\nis popped from the operand stack, and the value of the local\nvariable at index is set to objectref."
    },
    {
      "name": "astore_<n>",
      "operation": "Store reference into local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "astore_0",
          "value": 75
        },
        {
          "name": "astore_1",
          "value": 76
        },
        {
          "name": "astore_2",
          "value": 77
        },
        {
          "name": "astore_3",
          "value": 78
        }
      ],
      "stack": "..., objectref \u2192 ...",
      "description": "The <n> must be an index into the local variable array\nof the current frame (\u00a72.6). The objectref\non the top of the operand stack must be of type returnAddress or\nof type reference. It is popped from the operand stack, and the value\nof the local variable at <n> is set to\nobjectref."
    },
    {
      "name": "athrow",
      "operation": "Throw exception or error",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "athrow",
          "value": 191
        }
      ],
      "stack": "..., objectref \u2192 objectref",
      "description": "The objectref must be of type reference and must refer to an object\nthat is an instance of class Throwable or of a subclass of\nThrowable. It is popped from the operand stack. The objectref\nis then thrown by searching the current method\n(\u00a72.6) for the first exception handler that\nmatches the class of objectref, as given by the algorithm in\n\u00a72.10.\nIf an exception handler that matches objectref is found, it\ncontains the location of the code intended to handle this\nexception. The pc register is reset to that location, the\noperand stack of the current frame is cleared, objectref is\npushed back onto the operand stack, and execution\ncontinues.\nIf no matching exception handler is found in the current frame,\nthat frame is popped. If the current frame represents an\ninvocation of a synchronized method, the monitor entered or\nreentered on invocation of the method is exited as if by execution\nof a monitorexit instruction\n(\u00a7monitorexit). Finally, the frame of\nits invoker is reinstated, if such a frame exists, and the\nobjectref is rethrown. If no such frame exists, the current\nthread exits."
    },
    {
      "name": "baload",
      "operation": "Load byte or boolean from array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "baload",
          "value": 51
        }
      ],
      "stack": "..., arrayref, index \u2192 ..., value",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type byte or of type boolean. The\nindex must be of type int. Both arrayref and index are\npopped from the operand stack. The byte value in the component\nof the array at index is retrieved, sign-extended to an int\nvalue, and pushed onto the top of the operand stack."
    },
    {
      "name": "bastore",
      "operation": "Store into byte or boolean array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "bastore",
          "value": 84
        }
      ],
      "stack": "..., arrayref, index, value \u2192 ...",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type byte or of type boolean. The\nindex and the value must both be of type int. The arrayref,\nindex, and value are popped from the operand stack.\nIf the arrayref refers to an array whose components are of type byte,\nthen the int value is truncated to a byte and stored as\nthe component of the array indexed by index.\nIf the arrayref refers to an array whose components are of type\nboolean, then the int value is narrowed by taking the bitwise\nAND of value and 1; the result is stored as the component of the\narray indexed by index."
    },
    {
      "name": "bipush",
      "operation": "Push byte",
      "formats": [
        [
          "byte"
        ]
      ],
      "values": [
        {
          "name": "bipush",
          "value": 16
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The immediate byte is sign-extended to an int value. That value is pushed onto the operand stack."
    },
    {
      "name": "caload",
      "operation": "Load char from array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "caload",
          "value": 52
        }
      ],
      "stack": "..., arrayref, index \u2192 ..., value",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type char. The index must be of type\nint. Both arrayref and index are popped from the operand\nstack. The component of the array at index is retrieved and\nzero-extended to an int value. That value is pushed onto the\noperand stack."
    },
    {
      "name": "castore",
      "operation": "Store into char array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "castore",
          "value": 85
        }
      ],
      "stack": "..., arrayref, index, value \u2192 ...",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type char. The index and the value\nmust both be of type int. The arrayref, index, and value\nare popped from the operand stack. The int value is truncated\nto a char and stored as the component of the array indexed by\nindex."
    },
    {
      "name": "checkcast",
      "operation": "Check whether object is of given type",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "checkcast",
          "value": 192
        }
      ],
      "stack": "..., objectref \u2192 ..., objectref",
      "description": "The objectref must be of type reference. The unsigned indexbyte1\nand indexbyte2 are used to construct an index into the run-time\nconstant pool of the current class (\u00a72.6),\nwhere the value of the index is (indexbyte1 << 8) |\nindexbyte2. The run-time constant pool entry at the index must be\na symbolic reference to a class, array, or interface type.\nIf objectref is null, then the operand stack is unchanged.\nOtherwise, the named class, array, or interface type is resolved\n(\u00a75.4.3.1). If objectref can be cast to\nthe resolved class, array, or interface type, the operand stack is\nunchanged; otherwise, the checkcast instruction throws a\nClassCastException.\nThe following rules are used to determine whether an objectref\nthat is not null can be cast to the resolved type. If S is the\ntype of the object referred to by objectref, and T is the\nresolved class, array, or interface type, then checkcast\ndetermines whether objectref can be cast to type T as follows:\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by recursive application of these\nrules.\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by recursive application of these\nrules.\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by recursive application of these\nrules.\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by recursive application of these\nrules.\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by recursive application of these\nrules.\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by recursive application of these\nrules.\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by recursive application of these\nrules."
    },
    {
      "name": "d2f",
      "operation": "Convert double to float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "d2f",
          "value": 144
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\ndouble. It is popped from the operand stack and converted to a float result using\nthe round to nearest rounding\npolicy (\u00a72.8). The result is pushed onto the\noperand stack.\nA finite value too small to be represented as a float is\nconverted to a zero of the same sign; a finite value too large\nto be represented as a float is converted to an infinity of the\nsame sign. A double NaN is converted to a float NaN."
    },
    {
      "name": "d2i",
      "operation": "Convert double to int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "d2i",
          "value": 142
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\ndouble. It is popped from the operand stack and converted to an int result.\nThe result is pushed onto the operand stack:\nIf the value is NaN, the result of the conversion is an\nint 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as an int, then the result is the int value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type int, or\nthe value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type int.\nIf the value is NaN, the result of the conversion is an\nint 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as an int, then the result is the int value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type int, or\nthe value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type int.\nIf the value is NaN, the result of the conversion is an\nint 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as an int, then the result is the int value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type int, or\nthe value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type int."
    },
    {
      "name": "d2l",
      "operation": "Convert double to long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "d2l",
          "value": 143
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\ndouble. It is popped from the operand stack and converted to a long. The result is\npushed onto the operand stack:\nIf the value is NaN, the result of the conversion is a\nlong 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as a long, then the result is the long value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the result\nis the smallest representable value of type long, or the\nvalue must be too large (a positive value of large magnitude\nor positive infinity), and the result is the largest\nrepresentable value of type long.\nIf the value is NaN, the result of the conversion is a\nlong 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as a long, then the result is the long value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the result\nis the smallest representable value of type long, or the\nvalue must be too large (a positive value of large magnitude\nor positive infinity), and the result is the largest\nrepresentable value of type long.\nIf the value is NaN, the result of the conversion is a\nlong 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as a long, then the result is the long value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the result\nis the smallest representable value of type long, or the\nvalue must be too large (a positive value of large magnitude\nor positive infinity), and the result is the largest\nrepresentable value of type long."
    },
    {
      "name": "dadd",
      "operation": "Add double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dadd",
          "value": 99
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type double. The values\nare popped from the operand stack. The double result is value1 + value2. The\nresult is pushed onto the operand stack.\nThe result of a dadd instruction is governed by the rules of\nIEEE 754 arithmetic:\nIf either value1 or value2 is NaN, the result is NaN.\nThe sum of two infinities of opposite sign is NaN.\nThe sum of two infinities of the same sign is the infinity of that sign.\nThe sum of an infinity and any finite value is equal to the infinity.\nThe sum of two zeroes of opposite sign is positive zero.\nThe sum of two zeroes of the same sign is the zero of that sign.\nThe sum of a zero and a nonzero finite value is equal to the nonzero value.\nThe sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN and the values have the same sign or have\ndifferent magnitudes, the sum is computed and rounded to the\nnearest representable value using the round to nearest rounding policy\n(\u00a72.8). If the magnitude is too large to\nrepresent as a double, we say the operation overflows; the result\nis then\tan infinity of appropriate sign. If the magnitude is too small\nto represent as a double, we say the operation underflows;\nthe result is then a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nThe sum of two infinities of opposite sign is NaN.\nThe sum of two infinities of the same sign is the infinity of that sign.\nThe sum of an infinity and any finite value is equal to the infinity.\nThe sum of two zeroes of opposite sign is positive zero.\nThe sum of two zeroes of the same sign is the zero of that sign.\nThe sum of a zero and a nonzero finite value is equal to the nonzero value.\nThe sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN and the values have the same sign or have\ndifferent magnitudes, the sum is computed and rounded to the\nnearest representable value using the round to nearest rounding policy\n(\u00a72.8). If the magnitude is too large to\nrepresent as a double, we say the operation overflows; the result\nis then\tan infinity of appropriate sign. If the magnitude is too small\nto represent as a double, we say the operation underflows;\nthe result is then a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nThe sum of two infinities of opposite sign is NaN.\nThe sum of two infinities of the same sign is the infinity of that sign.\nThe sum of an infinity and any finite value is equal to the infinity.\nThe sum of two zeroes of opposite sign is positive zero.\nThe sum of two zeroes of the same sign is the zero of that sign.\nThe sum of a zero and a nonzero finite value is equal to the nonzero value.\nThe sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN and the values have the same sign or have\ndifferent magnitudes, the sum is computed and rounded to the\nnearest representable value using the round to nearest rounding policy\n(\u00a72.8). If the magnitude is too large to\nrepresent as a double, we say the operation overflows; the result\nis then\tan infinity of appropriate sign. If the magnitude is too small\nto represent as a double, we say the operation underflows;\nthe result is then a zero of appropriate sign.\nThe Java Virtual Machine requires support of gradual underflow.\nDespite the fact that overflow, underflow, or loss of\nprecision may occur, execution of a dadd instruction never\nthrows a run-time exception."
    },
    {
      "name": "daload",
      "operation": "Load double from array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "daload",
          "value": 49
        }
      ],
      "stack": "..., arrayref, index \u2192 ..., value",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type double. The index must be of type\nint. Both arrayref and index are popped from the operand\nstack. The double value in the component of the array at index\nis retrieved and pushed onto the operand stack."
    },
    {
      "name": "dastore",
      "operation": "Store into double array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dastore",
          "value": 82
        }
      ],
      "stack": "..., arrayref, index, value \u2192 ...",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type double. The index must be of type\nint, and value must be of type double. The arrayref,\nindex, and value are popped from the operand stack. The\ndouble value is\nstored as the component of the array indexed by index."
    },
    {
      "name": "dcmp<op>",
      "operation": "Compare double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dcmpg",
          "value": 152
        },
        {
          "name": "dcmpl",
          "value": 151
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type double. The values\nare popped from the operand stack and a floating-point comparison is performed:\nIf value1 is greater than value2, the int value 1 is\npushed onto the operand stack.\nOtherwise, if value1 is equal to value2, the int value\n0 is pushed onto the operand stack.\nOtherwise, if value1 is less than value2, the int\nvalue -1 is pushed onto the operand stack.\nOtherwise, at least one of value1 or value2 is NaN. The\ndcmpg instruction pushes the int value 1 onto the operand\nstack and the dcmpl instruction pushes the int value -1\nonto the operand stack.\nIf value1 is greater than value2, the int value 1 is\npushed onto the operand stack.\nOtherwise, if value1 is equal to value2, the int value\n0 is pushed onto the operand stack.\nOtherwise, if value1 is less than value2, the int\nvalue -1 is pushed onto the operand stack.\nOtherwise, at least one of value1 or value2 is NaN. The\ndcmpg instruction pushes the int value 1 onto the operand\nstack and the dcmpl instruction pushes the int value -1\nonto the operand stack.\nIf value1 is greater than value2, the int value 1 is\npushed onto the operand stack.\nOtherwise, if value1 is equal to value2, the int value\n0 is pushed onto the operand stack.\nOtherwise, if value1 is less than value2, the int\nvalue -1 is pushed onto the operand stack.\nOtherwise, at least one of value1 or value2 is NaN. The\ndcmpg instruction pushes the int value 1 onto the operand\nstack and the dcmpl instruction pushes the int value -1\nonto the operand stack.\nFloating-point comparison is performed in accordance with IEEE\n754. All values other than NaN are ordered, with negative infinity\nless than all finite values and positive infinity greater than all\nfinite values. Positive zero and negative zero are considered\nequal."
    },
    {
      "name": "dconst_<d>",
      "operation": "Push double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dconst_0",
          "value": 14
        },
        {
          "name": "dconst_1",
          "value": 15
        }
      ],
      "stack": "... \u2192 ..., <d>",
      "description": "Push the double constant <d> (0.0 or 1.0) onto the operand stack."
    },
    {
      "name": "ddiv",
      "operation": "Divide double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ddiv",
          "value": 111
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type double. The values\nare popped from the operand stack. The double result is value1 / value2. The\nresult is pushed onto the operand stack.\nThe result of a ddiv instruction is governed by the rules of\nIEEE 754 arithmetic:\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, negative\nif the values have different signs.\nDivision of an infinity by an infinity results in NaN.\nDivision of an infinity by a finite value results in a signed\ninfinity, with the sign-producing rule just given.\nDivision of a finite value by an infinity results in a signed\nzero, with the sign-producing rule just given.\nDivision of a zero by a zero results in NaN; division of zero\nby any other finite value results in a signed zero, with the\nsign-producing rule just given.\nDivision of a nonzero finite value by a zero results in a\nsigned infinity, with the sign-producing rule just\ngiven.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the quotient is computed and rounded to the\nnearest double using the\nround to nearest rounding policy (\u00a72.8).\nIf the magnitude is too large to represent as a double, we say the\noperation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a double, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, negative\nif the values have different signs.\nDivision of an infinity by an infinity results in NaN.\nDivision of an infinity by a finite value results in a signed\ninfinity, with the sign-producing rule just given.\nDivision of a finite value by an infinity results in a signed\nzero, with the sign-producing rule just given.\nDivision of a zero by a zero results in NaN; division of zero\nby any other finite value results in a signed zero, with the\nsign-producing rule just given.\nDivision of a nonzero finite value by a zero results in a\nsigned infinity, with the sign-producing rule just\ngiven.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the quotient is computed and rounded to the\nnearest double using the\nround to nearest rounding policy (\u00a72.8).\nIf the magnitude is too large to represent as a double, we say the\noperation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a double, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, negative\nif the values have different signs.\nDivision of an infinity by an infinity results in NaN.\nDivision of an infinity by a finite value results in a signed\ninfinity, with the sign-producing rule just given.\nDivision of a finite value by an infinity results in a signed\nzero, with the sign-producing rule just given.\nDivision of a zero by a zero results in NaN; division of zero\nby any other finite value results in a signed zero, with the\nsign-producing rule just given.\nDivision of a nonzero finite value by a zero results in a\nsigned infinity, with the sign-producing rule just\ngiven.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the quotient is computed and rounded to the\nnearest double using the\nround to nearest rounding policy (\u00a72.8).\nIf the magnitude is too large to represent as a double, we say the\noperation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a double, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nThe Java Virtual Machine requires support of gradual underflow.\nDespite the fact that overflow, underflow, division by zero,\nor loss of precision may occur, execution of a ddiv instruction\nnever throws a run-time exception."
    },
    {
      "name": "dload",
      "operation": "Load double from local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "dload",
          "value": 24
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The index is an unsigned byte. Both index and index+1 must\nbe indices into the local variable array of the current frame\n(\u00a72.6). The local variable at index must\ncontain a double. The value of the local variable at index\nis pushed onto the operand stack."
    },
    {
      "name": "dload_<n>",
      "operation": "Load double from local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dload_0",
          "value": 38
        },
        {
          "name": "dload_1",
          "value": 39
        },
        {
          "name": "dload_2",
          "value": 40
        },
        {
          "name": "dload_3",
          "value": 41
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "Both <n> and <n>+1 must be indices into the\nlocal variable array of the current frame\n(\u00a72.6). The local variable at <n>\nmust contain a double. The value of the local variable at\n<n> is pushed onto the operand stack."
    },
    {
      "name": "dmul",
      "operation": "Multiply double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dmul",
          "value": 107
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type double. The values\nare popped from the operand stack. The double result is value1 * value2. The\nresult is pushed onto the operand stack.\nThe result of a dmul instruction is governed by the rules of\nIEEE 754 arithmetic:\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign and\nnegative if the values have different signs.\nMultiplication of an infinity by a zero results in NaN.\nMultiplication of an infinity by a finite value results in a\nsigned infinity, with the sign-producing rule just given.\nIn the remaining cases, where neither an infinity nor NaN is\ninvolved, the product is computed and rounded to the nearest\nrepresentable value using the\nround to nearest rounding policy (\u00a72.8). If\nthe magnitude is too large to represent as a double, we say\nthe operation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a double, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign and\nnegative if the values have different signs.\nMultiplication of an infinity by a zero results in NaN.\nMultiplication of an infinity by a finite value results in a\nsigned infinity, with the sign-producing rule just given.\nIn the remaining cases, where neither an infinity nor NaN is\ninvolved, the product is computed and rounded to the nearest\nrepresentable value using the\nround to nearest rounding policy (\u00a72.8). If\nthe magnitude is too large to represent as a double, we say\nthe operation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a double, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign and\nnegative if the values have different signs.\nMultiplication of an infinity by a zero results in NaN.\nMultiplication of an infinity by a finite value results in a\nsigned infinity, with the sign-producing rule just given.\nIn the remaining cases, where neither an infinity nor NaN is\ninvolved, the product is computed and rounded to the nearest\nrepresentable value using the\nround to nearest rounding policy (\u00a72.8). If\nthe magnitude is too large to represent as a double, we say\nthe operation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a double, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nThe Java Virtual Machine requires support of gradual underflow.\nDespite the fact that overflow, underflow, or loss of\nprecision may occur, execution of a dmul instruction never\nthrows a run-time exception."
    },
    {
      "name": "dneg",
      "operation": "Negate double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dneg",
          "value": 119
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value must be of type double. It is popped from the operand\nstack. The\ndouble result is the arithmetic negation of value. The\nresult is pushed onto the operand stack.\nFor double values, negation is not the same as subtraction from\nzero. If x is +0.0,\nthen 0.0-x equals +0.0,\nbut -x equals -0.0. Unary\nminus merely inverts the sign of a double.\nSpecial cases of interest:\nIf the operand is NaN, the result is NaN (recall that NaN has\nno sign).\nThe Java Virtual Machine has not adopted the stronger requirement from the\n2019 version of the IEEE 754 Standard that negation inverts\nthe sign bit for all inputs, including NaN.\nIf the operand is an infinity, the result is the infinity of\nopposite sign.\nIf the operand is a zero, the result is the zero of opposite\nsign.\nIf the operand is NaN, the result is NaN (recall that NaN has\nno sign).\nThe Java Virtual Machine has not adopted the stronger requirement from the\n2019 version of the IEEE 754 Standard that negation inverts\nthe sign bit for all inputs, including NaN.\nIf the operand is an infinity, the result is the infinity of\nopposite sign.\nIf the operand is a zero, the result is the zero of opposite\nsign.\nIf the operand is NaN, the result is NaN (recall that NaN has\nno sign).\nIf the operand is an infinity, the result is the infinity of\nopposite sign.\nIf the operand is a zero, the result is the zero of opposite\nsign."
    },
    {
      "name": "drem",
      "operation": "Remainder double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "drem",
          "value": 115
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type double. The values\nare popped from the operand stack. The double result is calculated and pushed onto the\noperand stack.\nThe result of a drem instruction is not the same as the result of\nthe remainder operation defined by IEEE 754, due to the choice of\nrounding policy in the Java Virtual Machine (\u00a72.8).\nThe IEEE 754 remainder operation computes the remainder from a rounding\ndivision, not a truncating division, and so its behavior\nis not analogous to that of the usual integer\nremainder operator. Instead, the Java Virtual Machine defines drem to behave in\na manner analogous to that of the integer remainder\ninstructions irem and lrem, with an implied division using the\nround toward zero rounding policy; this may be compared with the C\nlibrary function fmod.\nThe result of a drem instruction is governed by the following\nrules, which match IEEE 754 arithmetic except for how the\nimplied division is computed:\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult equals the sign of the dividend.\nIf the dividend is an infinity or the divisor is a zero or\nboth, the result is NaN.\nIf the dividend is finite and the divisor is an infinity, the\nresult equals the dividend.\nIf the dividend is a zero and the divisor is finite, the\nresult equals the dividend.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the floating-point remainder result from a\ndividend value1 and a divisor value2 is defined by the\nmathematical relation result = value1 - (value2 *\nq), where q is an integer that is negative only if\nvalue1 / value2 is negative, and positive only if\nvalue1 / value2 is positive, and whose magnitude is as\nlarge as possible without exceeding the magnitude of the true\nmathematical quotient of value1 and value2.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult equals the sign of the dividend.\nIf the dividend is an infinity or the divisor is a zero or\nboth, the result is NaN.\nIf the dividend is finite and the divisor is an infinity, the\nresult equals the dividend.\nIf the dividend is a zero and the divisor is finite, the\nresult equals the dividend.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the floating-point remainder result from a\ndividend value1 and a divisor value2 is defined by the\nmathematical relation result = value1 - (value2 *\nq), where q is an integer that is negative only if\nvalue1 / value2 is negative, and positive only if\nvalue1 / value2 is positive, and whose magnitude is as\nlarge as possible without exceeding the magnitude of the true\nmathematical quotient of value1 and value2.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult equals the sign of the dividend.\nIf the dividend is an infinity or the divisor is a zero or\nboth, the result is NaN.\nIf the dividend is finite and the divisor is an infinity, the\nresult equals the dividend.\nIf the dividend is a zero and the divisor is finite, the\nresult equals the dividend.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the floating-point remainder result from a\ndividend value1 and a divisor value2 is defined by the\nmathematical relation result = value1 - (value2 *\nq), where q is an integer that is negative only if\nvalue1 / value2 is negative, and positive only if\nvalue1 / value2 is positive, and whose magnitude is as\nlarge as possible without exceeding the magnitude of the true\nmathematical quotient of value1 and value2.\nDespite the fact that division by zero may occur, evaluation of a\ndrem instruction never throws a run-time exception. Overflow,\nunderflow, or loss of precision cannot occur."
    },
    {
      "name": "dreturn",
      "operation": "Return double from method",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dreturn",
          "value": 175
        }
      ],
      "stack": "..., value \u2192 [empty]",
      "description": "The current method must have return type double. The value\nmust be of type double. If the current method is a\nsynchronized method, the monitor entered or reentered on\ninvocation of the method is updated and possibly exited as if by\nexecution of a monitorexit instruction (\u00a7monitorexit) in the current thread. If no\nexception is thrown, value is popped from the operand stack of\nthe current frame (\u00a72.6) and pushed onto the operand stack of the\nframe of the invoker. Any other values on the operand stack of the\ncurrent method are discarded.\nThe interpreter then returns control to the invoker of the method,\nreinstating the frame of the invoker."
    },
    {
      "name": "dstore",
      "operation": "Store double into local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "dstore",
          "value": 57
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The index is an unsigned byte. Both index and index+1 must\nbe indices into the local variable array of the current frame\n(\u00a72.6). The value on the top of the\noperand stack must be of type double. It is popped from the\noperand stack.\nThe local variables at index and index+1 are set to value."
    },
    {
      "name": "dstore_<n>",
      "operation": "Store double into local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dstore_0",
          "value": 71
        },
        {
          "name": "dstore_1",
          "value": 72
        },
        {
          "name": "dstore_2",
          "value": 73
        },
        {
          "name": "dstore_3",
          "value": 74
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "Both <n> and <n>+1 must be indices into the\nlocal variable array of the current frame\n(\u00a72.6). The value on the top of the\noperand stack must be of type double. It is popped from the\noperand stack.\nThe local variables at <n> and <n>+1 are set to\nvalue."
    },
    {
      "name": "dsub",
      "operation": "Subtract double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dsub",
          "value": 103
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type double. The values\nare popped from the operand stack. The double result is value1 - value2. The\nresult is pushed onto the operand stack.\nFor double subtraction, it is always the case\nthat a-b produces the same result\nas a+(-b). However, for the dsub instruction,\nsubtraction from zero is not the same as negation, because\nif x is +0.0,\nthen 0.0-x equals +0.0,\nbut -x equals -0.0.\nThe Java Virtual Machine requires support of gradual underflow.\nDespite the fact that overflow, underflow, or loss of\nprecision may occur, execution of a dsub instruction never\nthrows a run-time exception."
    },
    {
      "name": "dup",
      "operation": "Duplicate the top operand stack value",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dup",
          "value": 89
        }
      ],
      "stack": "..., value \u2192 ..., value, value",
      "description": "Duplicate the top value on the operand stack and push the\nduplicated value onto the operand stack.\nThe dup instruction must not be used unless value is a value\nof a category 1 computational type\n(\u00a72.11.1)."
    },
    {
      "name": "dup_x1",
      "operation": "Duplicate the top operand stack value and insert two values down",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dup_x1",
          "value": 90
        }
      ],
      "stack": "..., value2, value1 \u2192 ..., value1, value2, value1",
      "description": "Duplicate the top value on the operand stack and insert the\nduplicated value two values down in the operand stack.\nThe dup_x1 instruction must not be used unless both value1 and\nvalue2 are values of a category 1 computational type\n(\u00a72.11.1)."
    },
    {
      "name": "dup_x2",
      "operation": "Duplicate the top operand stack value and insert two or three values down",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dup_x2",
          "value": 91
        }
      ],
      "stack": "Form 1: ..., value3, value2, value1 \u2192 ..., value1, value3, value2, value1 where value1, value2, and value3 are all values of a\ncategory 1 computational type\n(\u00a72.11.1). Form 2: ..., value2, value1 \u2192 ..., value1, value2, value1 where value1 is a value of a category 1 computational type and\nvalue2 is a value of a category 2 computational type\n(\u00a72.11.1).",
      "description": "Duplicate the top value on the operand stack and insert the\nduplicated value two or three values down in the operand\nstack."
    },
    {
      "name": "dup2",
      "operation": "Duplicate the top one or two operand stack values",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dup2",
          "value": 92
        }
      ],
      "stack": "Form 1: ..., value2, value1 \u2192 ..., value2, value1, value2, value1 where both value1 and value2 are values of a category 1\ncomputational type (\u00a72.11.1). Form 2: ..., value \u2192 ..., value, value where value is a value of a category 2 computational type\n(\u00a72.11.1).",
      "description": "Duplicate the top one or two values on the operand stack and push\nthe duplicated value or values back onto the operand stack in the\noriginal order."
    },
    {
      "name": "dup2_x1",
      "operation": "Duplicate the top one or two operand stack values and insert two or three values down",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dup2_x1",
          "value": 93
        }
      ],
      "stack": "Form 1: ..., value3, value2, value1 \u2192 ..., value2, value1, value3, value2, value1 where value1, value2, and value3 are all values of a\ncategory 1 computational type\n(\u00a72.11.1). Form 2: ..., value2, value1 \u2192 ..., value1, value2, value1 where value1 is a value of a category 2 computational type and\nvalue2 is a value of a category 1 computational type\n(\u00a72.11.1).",
      "description": "Duplicate the top one or two values on the operand stack and\ninsert the duplicated values, in the original order, one value\nbeneath the original value or values in the operand stack."
    },
    {
      "name": "dup2_x2",
      "operation": "Duplicate the top one or two operand stack values and insert two, three, or four values down",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "dup2_x2",
          "value": 94
        }
      ],
      "stack": "Form 1: ..., value4, value3, value2, value1 \u2192 ..., value2, value1, value4, value3, value2, value1 where value1, value2, value3, and value4 are all values of\na category 1 computational type\n(\u00a72.11.1). Form 2: ..., value3, value2, value1 \u2192 ..., value1, value3, value2, value1 where value1 is a value of a category 2 computational type and\nvalue2 and value3 are both values of a category 1\ncomputational type (\u00a72.11.1). Form 3: ..., value3, value2, value1 \u2192 ..., value2, value1, value3, value2, value1 where value1 and value2 are both values of a category 1\ncomputational type and value3 is a value of a category 2\ncomputational type (\u00a72.11.1). Form 4: ..., value2, value1 \u2192 ..., value1, value2, value1 where value1 and value2 are both values of a category 2\ncomputational type (\u00a72.11.1).",
      "description": "Duplicate the top one or two values on the operand stack and\ninsert the duplicated values, in the original order, into the\noperand stack."
    },
    {
      "name": "f2d",
      "operation": "Convert float to double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "f2d",
          "value": 141
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nfloat. It is popped from the operand stack and converted to a double result.\nThe result is pushed onto the operand stack."
    },
    {
      "name": "f2i",
      "operation": "Convert float to int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "f2i",
          "value": 139
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nfloat. It is popped from the operand stack and converted to an int result. The\nresult is pushed onto the operand stack:\nIf the value is NaN, the result of the conversion is an\nint 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as an int, then the result is the int value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type int, or\nthe value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type int.\nIf the value is NaN, the result of the conversion is an\nint 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as an int, then the result is the int value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type int, or\nthe value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type int.\nIf the value is NaN, the result of the conversion is an\nint 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as an int, then the result is the int value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type int, or\nthe value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type int."
    },
    {
      "name": "f2l",
      "operation": "Convert float to long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "f2l",
          "value": 140
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nfloat. It is popped from the operand stack and converted to a long result. The\nresult is pushed onto the operand stack:\nIf the value is NaN, the result of the conversion is a\nlong 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as a long, then the result is the long value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type long,\nor the value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type long.\nIf the value is NaN, the result of the conversion is a\nlong 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as a long, then the result is the long value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type long,\nor the value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type long.\nIf the value is NaN, the result of the conversion is a\nlong 0.\nOtherwise, if the value is not an infinity, it is rounded\nto an integer value V using the round toward zero rounding\npolicy (\u00a72.8). If this integer value V can be\nrepresented as a long, then the result is the long value\nV.\nOtherwise, either the value must be too small (a negative\nvalue of large magnitude or negative infinity), and the\nresult is the smallest representable value of type long,\nor the value must be too large (a positive value of large\nmagnitude or positive infinity), and the result is the\nlargest representable value of type long."
    },
    {
      "name": "fadd",
      "operation": "Add float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fadd",
          "value": 98
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type float. The values are\npopped from the operand stack. The float result is value1 + value2. The\nresult is pushed onto the operand stack.\nThe result of an fadd instruction is governed by the rules of\nIEEE 754 arithmetic:\nIf either value1 or value2 is NaN, the result is NaN.\nThe sum of two infinities of opposite sign is NaN.\nThe sum of two infinities of the same sign is the infinity of\nthat sign.\nThe sum of an infinity and any finite value is equal to the\ninfinity.\nThe sum of two zeroes of opposite sign is positive\nzero.\nThe sum of two zeroes of the same sign is the zero of that\nsign.\nThe sum of a zero and a nonzero finite value is equal to the\nnonzero value.\nThe sum of two nonzero finite values of the same magnitude and\nopposite sign is positive zero.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN and the values have the same sign or have\ndifferent magnitudes, the sum is computed and rounded to the\nnearest representable value using the round to nearest rounding policy\n(\u00a72.8). If the magnitude is too large\nto represent as a float, we say the operation overflows;\nthe result is then an infinity of appropriate sign.\nIf the magnitude is too small to represent as a float,\nwe say the operation underflows; the result is then a\nzero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nThe sum of two infinities of opposite sign is NaN.\nThe sum of two infinities of the same sign is the infinity of\nthat sign.\nThe sum of an infinity and any finite value is equal to the\ninfinity.\nThe sum of two zeroes of opposite sign is positive\nzero.\nThe sum of two zeroes of the same sign is the zero of that\nsign.\nThe sum of a zero and a nonzero finite value is equal to the\nnonzero value.\nThe sum of two nonzero finite values of the same magnitude and\nopposite sign is positive zero.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN and the values have the same sign or have\ndifferent magnitudes, the sum is computed and rounded to the\nnearest representable value using the round to nearest rounding policy\n(\u00a72.8). If the magnitude is too large\nto represent as a float, we say the operation overflows;\nthe result is then an infinity of appropriate sign.\nIf the magnitude is too small to represent as a float,\nwe say the operation underflows; the result is then a\nzero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nThe sum of two infinities of opposite sign is NaN.\nThe sum of two infinities of the same sign is the infinity of\nthat sign.\nThe sum of an infinity and any finite value is equal to the\ninfinity.\nThe sum of two zeroes of opposite sign is positive\nzero.\nThe sum of two zeroes of the same sign is the zero of that\nsign.\nThe sum of a zero and a nonzero finite value is equal to the\nnonzero value.\nThe sum of two nonzero finite values of the same magnitude and\nopposite sign is positive zero.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN and the values have the same sign or have\ndifferent magnitudes, the sum is computed and rounded to the\nnearest representable value using the round to nearest rounding policy\n(\u00a72.8). If the magnitude is too large\nto represent as a float, we say the operation overflows;\nthe result is then an infinity of appropriate sign.\nIf the magnitude is too small to represent as a float,\nwe say the operation underflows; the result is then a\nzero of appropriate sign.\nThe Java Virtual Machine requires support of gradual underflow.\nDespite the fact that overflow, underflow, or loss of\nprecision may occur, execution of an fadd instruction never\nthrows a run-time exception."
    },
    {
      "name": "faload",
      "operation": "Load float from array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "faload",
          "value": 48
        }
      ],
      "stack": "..., arrayref, index \u2192 ..., value",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type float. The index must be of type\nint. Both arrayref and index are popped from the operand\nstack. The float value in the component of the array at index\nis retrieved and pushed onto the operand stack."
    },
    {
      "name": "fastore",
      "operation": "Store into float array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fastore",
          "value": 81
        }
      ],
      "stack": "..., arrayref, index, value \u2192 ...",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type float. The index must be of type\nint, and the value must be of type float. The arrayref,\nindex, and value are popped from the operand stack. The\nfloat value is\nstored as the component of the array indexed by index."
    },
    {
      "name": "fcmp<op>",
      "operation": "Compare float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fcmpg",
          "value": 150
        },
        {
          "name": "fcmpl",
          "value": 149
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type float. The values are\npopped from the operand stack and a floating-point comparison is performed:\nIf value1 is greater than value2, the int value 1 is\npushed onto the operand stack.\nOtherwise, if value1 is equal to value2, the int value\n0 is pushed onto the operand stack.\nOtherwise, if value1 is less than value2, the int\nvalue -1 is pushed onto the operand stack.\nOtherwise, at least one of value1 or value2 is NaN. The\nfcmpg instruction pushes the int value 1 onto the operand\nstack and the fcmpl instruction pushes the int value -1\nonto the operand stack.\nIf value1 is greater than value2, the int value 1 is\npushed onto the operand stack.\nOtherwise, if value1 is equal to value2, the int value\n0 is pushed onto the operand stack.\nOtherwise, if value1 is less than value2, the int\nvalue -1 is pushed onto the operand stack.\nOtherwise, at least one of value1 or value2 is NaN. The\nfcmpg instruction pushes the int value 1 onto the operand\nstack and the fcmpl instruction pushes the int value -1\nonto the operand stack.\nIf value1 is greater than value2, the int value 1 is\npushed onto the operand stack.\nOtherwise, if value1 is equal to value2, the int value\n0 is pushed onto the operand stack.\nOtherwise, if value1 is less than value2, the int\nvalue -1 is pushed onto the operand stack.\nOtherwise, at least one of value1 or value2 is NaN. The\nfcmpg instruction pushes the int value 1 onto the operand\nstack and the fcmpl instruction pushes the int value -1\nonto the operand stack.\nFloating-point comparison is performed in accordance with IEEE\n754. All values other than NaN are ordered, with negative infinity\nless than all finite values and positive infinity greater than all\nfinite values. Positive zero and negative zero are considered\nequal."
    },
    {
      "name": "fconst_<f>",
      "operation": "Push float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fconst_0",
          "value": 11
        },
        {
          "name": "fconst_1",
          "value": 12
        },
        {
          "name": "fconst_2",
          "value": 13
        }
      ],
      "stack": "... \u2192 ..., <f>",
      "description": "Push the float constant <f> (0.0, 1.0, or 2.0) onto the operand stack."
    },
    {
      "name": "fdiv",
      "operation": "Divide float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fdiv",
          "value": 110
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type float. The values are\npopped from the operand stack. The float result is value1 / value2. The\nresult is pushed onto the operand stack.\nThe result of an fdiv instruction is governed by the rules of\nIEEE 754 arithmetic:\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, negative\nif the values have different signs.\nDivision of an infinity by an infinity results in NaN.\nDivision of an infinity by a finite value results in a signed\ninfinity, with the sign-producing rule just given.\nDivision of a finite value by an infinity results in a signed\nzero, with the sign-producing rule just given.\nDivision of a zero by a zero results in NaN; division of zero\nby any other finite value results in a signed zero, with the\nsign-producing rule just given.\nDivision of a nonzero finite value by a zero results in a\nsigned infinity, with the sign-producing rule just\ngiven.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the quotient is computed and rounded to the\nnearest float using the\nround to nearest rounding policy (\u00a72.8). If the\nmagnitude is too large to represent as a float, we say the\noperation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a float, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, negative\nif the values have different signs.\nDivision of an infinity by an infinity results in NaN.\nDivision of an infinity by a finite value results in a signed\ninfinity, with the sign-producing rule just given.\nDivision of a finite value by an infinity results in a signed\nzero, with the sign-producing rule just given.\nDivision of a zero by a zero results in NaN; division of zero\nby any other finite value results in a signed zero, with the\nsign-producing rule just given.\nDivision of a nonzero finite value by a zero results in a\nsigned infinity, with the sign-producing rule just\ngiven.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the quotient is computed and rounded to the\nnearest float using the\nround to nearest rounding policy (\u00a72.8). If the\nmagnitude is too large to represent as a float, we say the\noperation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a float, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, negative\nif the values have different signs.\nDivision of an infinity by an infinity results in NaN.\nDivision of an infinity by a finite value results in a signed\ninfinity, with the sign-producing rule just given.\nDivision of a finite value by an infinity results in a signed\nzero, with the sign-producing rule just given.\nDivision of a zero by a zero results in NaN; division of zero\nby any other finite value results in a signed zero, with the\nsign-producing rule just given.\nDivision of a nonzero finite value by a zero results in a\nsigned infinity, with the sign-producing rule just\ngiven.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the quotient is computed and rounded to the\nnearest float using the\nround to nearest rounding policy (\u00a72.8). If the\nmagnitude is too large to represent as a float, we say the\noperation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a float, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nThe Java Virtual Machine requires support of gradual underflow.\nDespite the fact that overflow, underflow, division by zero,\nor loss of precision may occur, execution of an fdiv instruction\nnever throws a run-time exception."
    },
    {
      "name": "fload",
      "operation": "Load float from local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "fload",
          "value": 23
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The index is an unsigned byte that must be an index into the\nlocal variable array of the current frame\n(\u00a72.6). The local variable at index must\ncontain a float. The value of the local variable at index is\npushed onto the operand stack."
    },
    {
      "name": "fload_<n>",
      "operation": "Load float from local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fload_0",
          "value": 34
        },
        {
          "name": "fload_1",
          "value": 35
        },
        {
          "name": "fload_2",
          "value": 36
        },
        {
          "name": "fload_3",
          "value": 37
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The <n> must be an index into the local variable array\nof the current frame (\u00a72.6). The local\nvariable at <n> must contain a float. The value of\nthe local variable at <n> is pushed onto the operand\nstack."
    },
    {
      "name": "fmul",
      "operation": "Multiply float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fmul",
          "value": 106
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type float. The values are\npopped from the operand stack. The float result is value1 * value2. The\nresult is pushed onto the operand stack.\nThe result of an fmul instruction is governed by the rules of\nIEEE 754 arithmetic:\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, and\nnegative if the values have different signs.\nMultiplication of an infinity by a zero results in NaN.\nMultiplication of an infinity by a finite value results in a\nsigned infinity, with the sign-producing rule just given.\nIn the remaining cases, where neither an infinity nor NaN is\ninvolved, the product is computed and rounded to the nearest\nrepresentable value using\nthe round to nearest rounding policy (\u00a72.8).\nIf the magnitude is too large to represent as a float, we say\nthe operation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a float, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, and\nnegative if the values have different signs.\nMultiplication of an infinity by a zero results in NaN.\nMultiplication of an infinity by a finite value results in a\nsigned infinity, with the sign-producing rule just given.\nIn the remaining cases, where neither an infinity nor NaN is\ninvolved, the product is computed and rounded to the nearest\nrepresentable value using\nthe round to nearest rounding policy (\u00a72.8).\nIf the magnitude is too large to represent as a float, we say\nthe operation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a float, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult is positive if both values have the same sign, and\nnegative if the values have different signs.\nMultiplication of an infinity by a zero results in NaN.\nMultiplication of an infinity by a finite value results in a\nsigned infinity, with the sign-producing rule just given.\nIn the remaining cases, where neither an infinity nor NaN is\ninvolved, the product is computed and rounded to the nearest\nrepresentable value using\nthe round to nearest rounding policy (\u00a72.8).\nIf the magnitude is too large to represent as a float, we say\nthe operation overflows; the result is then an infinity of\nappropriate sign. If the magnitude is too small to represent\nas a float, we say the operation underflows; the result is\nthen a zero of appropriate sign.\nThe Java Virtual Machine requires support of gradual underflow.\nDespite the fact that overflow, underflow, or loss of\nprecision may occur, execution of an fmul instruction never\nthrows a run-time exception."
    },
    {
      "name": "fneg",
      "operation": "Negate float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fneg",
          "value": 118
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value must be of type float. It is popped from the operand\nstack. The float\nresult is the arithmetic negation of value. The result is\npushed onto the operand stack.\nFor float values, negation is not the same as subtraction from\nzero. If x is +0.0,\nthen 0.0-x equals +0.0,\nbut -x equals -0.0. Unary\nminus merely inverts the sign of a float.\nSpecial cases of interest:\nIf the operand is NaN, the result is NaN (recall that NaN has\nno sign).\nThe Java Virtual Machine has not adopted the stronger requirement from the\n2019 version of the IEEE 754 Standard that negation inverts\nthe sign bit for all inputs, including NaN.\nIf the operand is an infinity, the result is the infinity of\nopposite sign.\nIf the operand is a zero, the result is the zero of opposite\nsign.\nIf the operand is NaN, the result is NaN (recall that NaN has\nno sign).\nThe Java Virtual Machine has not adopted the stronger requirement from the\n2019 version of the IEEE 754 Standard that negation inverts\nthe sign bit for all inputs, including NaN.\nIf the operand is an infinity, the result is the infinity of\nopposite sign.\nIf the operand is a zero, the result is the zero of opposite\nsign.\nIf the operand is NaN, the result is NaN (recall that NaN has\nno sign).\nIf the operand is an infinity, the result is the infinity of\nopposite sign.\nIf the operand is a zero, the result is the zero of opposite\nsign."
    },
    {
      "name": "frem",
      "operation": "Remainder float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "frem",
          "value": 114
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type float. The values are\npopped from the operand stack. The float result is calculated and pushed onto the\noperand stack.\nThe result of an frem instruction is not the same as the result of\nthe remainder operation defined by IEEE 754, due to the choice of\nrounding policy in the Java Virtual Machine (\u00a72.8).\nThe IEEE 754 remainder operation computes the remainder from a rounding\ndivision, not a truncating division, and so its behavior\nis not analogous to that of the usual integer\nremainder operator. Instead, the Java Virtual Machine defines frem to behave in\na manner analogous to that of the integer remainder\ninstructions irem and lrem, with an implied division using the\nround toward zero rounding policy; this may be compared with the C\nlibrary function fmod.\nThe result of an frem instruction is governed by the following\nrules, which match IEEE 754 arithmetic except for how the\nimplied division is computed:\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult equals the sign of the dividend.\nIf the dividend is an infinity or the divisor is a zero or\nboth, the result is NaN.\nIf the dividend is finite and the divisor is an infinity, the\nresult equals the dividend.\nIf the dividend is a zero and the divisor is finite, the\nresult equals the dividend.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the floating-point remainder result from a\ndividend value1 and a divisor value2 is defined by the\nmathematical relation result = value1 - (value2 *\nq), where q is an integer that is negative only if\nvalue1 / value2 is negative, and positive only if\nvalue1 / value2 is positive, and whose magnitude is as\nlarge as possible without exceeding the magnitude of the true\nmathematical quotient of value1 and value2.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult equals the sign of the dividend.\nIf the dividend is an infinity or the divisor is a zero or\nboth, the result is NaN.\nIf the dividend is finite and the divisor is an infinity, the\nresult equals the dividend.\nIf the dividend is a zero and the divisor is finite, the\nresult equals the dividend.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the floating-point remainder result from a\ndividend value1 and a divisor value2 is defined by the\nmathematical relation result = value1 - (value2 *\nq), where q is an integer that is negative only if\nvalue1 / value2 is negative, and positive only if\nvalue1 / value2 is positive, and whose magnitude is as\nlarge as possible without exceeding the magnitude of the true\nmathematical quotient of value1 and value2.\nIf either value1 or value2 is NaN, the result is NaN.\nIf neither value1 nor value2 is NaN, the sign of the\nresult equals the sign of the dividend.\nIf the dividend is an infinity or the divisor is a zero or\nboth, the result is NaN.\nIf the dividend is finite and the divisor is an infinity, the\nresult equals the dividend.\nIf the dividend is a zero and the divisor is finite, the\nresult equals the dividend.\nIn the remaining cases, where neither operand is an infinity,\na zero, or NaN, the floating-point remainder result from a\ndividend value1 and a divisor value2 is defined by the\nmathematical relation result = value1 - (value2 *\nq), where q is an integer that is negative only if\nvalue1 / value2 is negative, and positive only if\nvalue1 / value2 is positive, and whose magnitude is as\nlarge as possible without exceeding the magnitude of the true\nmathematical quotient of value1 and value2.\nDespite the fact that division by zero may occur, evaluation of an\nfrem instruction never throws a run-time exception. Overflow,\nunderflow, or loss of precision cannot occur."
    },
    {
      "name": "freturn",
      "operation": "Return float from method",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "freturn",
          "value": 174
        }
      ],
      "stack": "..., value \u2192 [empty]",
      "description": "The current method must have return type float. The value must\nbe of type float. If the current method is a synchronized\nmethod, the monitor entered or reentered on invocation of the\nmethod is updated and possibly exited as if by execution of a\nmonitorexit instruction (\u00a7monitorexit)\nin the current thread. If no exception is thrown, value is\npopped from the operand stack of the current frame (\u00a72.6) and pushed onto the operand stack of the frame of the\ninvoker. Any other values on the operand stack of the current\nmethod are discarded.\nThe interpreter then returns control to the invoker of the method,\nreinstating the frame of the invoker."
    },
    {
      "name": "fstore",
      "operation": "Store float into local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "fstore",
          "value": 56
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The index is an unsigned byte that must be an index into the\nlocal variable array of the current frame (\u00a72.6). The value on the top of the operand stack\nmust be of type float. It is popped from the operand stack, and\nthe value of\nthe local variable at index is set to value."
    },
    {
      "name": "fstore_<n>",
      "operation": "Store float into local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fstore_0",
          "value": 67
        },
        {
          "name": "fstore_1",
          "value": 68
        },
        {
          "name": "fstore_2",
          "value": 69
        },
        {
          "name": "fstore_3",
          "value": 70
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The <n> must be an index into the local variable array\nof the current frame (\u00a72.6). The value on\nthe top of the operand stack must be of type float. It is popped\nfrom the operand stack, and the value\nof the local variable at <n> is set to value."
    },
    {
      "name": "fsub",
      "operation": "Subtract float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "fsub",
          "value": 102
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type float. The values are\npopped from the operand stack. The float result is value1 - value2. The\nresult is pushed onto the operand stack.\nFor float subtraction, it is always the case\nthat a-b produces the same result\nas a+(-b). However, for the fsub instruction,\nsubtraction from zero is not the same as negation, because\nif x is +0.0,\nthen 0.0-x equals +0.0,\nbut -x equals -0.0.\nThe Java Virtual Machine requires support of gradual underflow.\nDespite the fact that overflow, underflow, or loss of\nprecision may occur, execution of an fsub instruction never\nthrows a run-time exception."
    },
    {
      "name": "getfield",
      "operation": "Fetch field from object",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "getfield",
          "value": 180
        }
      ],
      "stack": "..., objectref \u2192 ..., value",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a field\n(\u00a75.1), which gives the name and descriptor\nof the field as well as a symbolic reference to the class in which\nthe field is to be found. The referenced field is resolved\n(\u00a75.4.3.2).\nThe objectref, which must be\nof type reference but not an array type, is popped from the operand\nstack. The value of the referenced field in objectref is fetched\nand pushed onto the operand stack."
    },
    {
      "name": "getstatic",
      "operation": "Get static field from class",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "getstatic",
          "value": 178
        }
      ],
      "stack": "..., \u2192 ..., value",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a field\n(\u00a75.1), which gives the name and descriptor\nof the field as well as a symbolic reference to the class or\ninterface in which the field is to be found. The referenced field\nis resolved (\u00a75.4.3.2).\nOn successful resolution of the field, the class or interface that\ndeclared the resolved field is initialized if that class or\ninterface has not already been initialized (\u00a75.5).\nThe value of the class or interface field is fetched and pushed\nonto the operand stack."
    },
    {
      "name": "goto",
      "operation": "Branch always",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2"
        ]
      ],
      "values": [
        {
          "name": "goto",
          "value": 167
        }
      ],
      "stack": "No change",
      "description": "The unsigned bytes branchbyte1 and branchbyte2 are used to\nconstruct a signed 16-bit branchoffset, where branchoffset is\n(branchbyte1 << 8) | branchbyte2. Execution proceeds at\nthat offset from the address of the opcode of this goto\ninstruction. The target address must be that of an opcode of an\ninstruction within the method that contains this goto\ninstruction."
    },
    {
      "name": "goto_w",
      "operation": "Branch always (wide index)",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2",
          "branchbyte3",
          "branchbyte4"
        ]
      ],
      "values": [
        {
          "name": "goto_w",
          "value": 200
        }
      ],
      "stack": "No change",
      "description": "The unsigned bytes branchbyte1, branchbyte2, branchbyte3,\nand branchbyte4 are used to construct a signed 32-bit\nbranchoffset, where branchoffset is (branchbyte1 <<\n24) | (branchbyte2 << 16) | (branchbyte3 << 8) |\nbranchbyte4. Execution proceeds at that offset from the address\nof the opcode of this goto_w instruction. The target address\nmust be that of an opcode of an instruction within the method that\ncontains this goto_w instruction."
    },
    {
      "name": "i2b",
      "operation": "Convert int to byte",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "i2b",
          "value": 145
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nint. It is popped from the operand stack, truncated to a byte,\nthen sign-extended to an int result. The result is pushed\nonto the operand stack."
    },
    {
      "name": "i2c",
      "operation": "Convert int to char",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "i2c",
          "value": 146
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nint. It is popped from the operand stack, truncated to char,\nthen zero-extended to an int result. The result is pushed\nonto the operand stack."
    },
    {
      "name": "i2d",
      "operation": "Convert int to double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "i2d",
          "value": 135
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nint. It is popped from the operand stack and converted to a\ndouble result. The result is pushed onto the operand\nstack."
    },
    {
      "name": "i2f",
      "operation": "Convert int to float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "i2f",
          "value": 134
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nint. It is popped from the operand stack and converted to a\nfloat result using the\nround to nearest rounding policy (\u00a72.8).\nThe result is pushed onto the operand stack."
    },
    {
      "name": "i2l",
      "operation": "Convert int to long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "i2l",
          "value": 133
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nint. It is popped from the operand stack and sign-extended to a\nlong result. The result is pushed onto the operand\nstack."
    },
    {
      "name": "i2s",
      "operation": "Convert int to short",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "i2s",
          "value": 147
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nint. It is popped from the operand stack, truncated to a\nshort, then sign-extended to an int result. The result is\npushed onto the operand stack."
    },
    {
      "name": "iadd",
      "operation": "Add int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "iadd",
          "value": 96
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. The values are\npopped from the operand stack. The int result is value1 +\nvalue2. The result is pushed onto the operand stack.\nThe result is the 32 low-order bits of the true mathematical\nresult in a sufficiently wide two's-complement format, represented\nas a value of type int. If overflow occurs, then the sign of the\nresult may not be the same as the sign of the mathematical sum of\nthe two values.\nDespite the fact that overflow may occur, execution of an iadd\ninstruction never throws a run-time exception."
    },
    {
      "name": "iaload",
      "operation": "Load int from array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "iaload",
          "value": 46
        }
      ],
      "stack": "..., arrayref, index \u2192 ..., value",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type int. The index must be of type\nint. Both arrayref and index are popped from the operand\nstack. The int value in the component of the array at index\nis retrieved and pushed onto the operand stack."
    },
    {
      "name": "iand",
      "operation": "Boolean AND int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "iand",
          "value": 126
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. They are popped\nfrom the operand stack. An int result is calculated by taking\nthe bitwise AND (conjunction) of value1 and value2. The\nresult is pushed onto the operand stack."
    },
    {
      "name": "iastore",
      "operation": "Store into int array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "iastore",
          "value": 79
        }
      ],
      "stack": "..., arrayref, index, value \u2192 ...",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type int. Both index and value must\nbe of type int. The arrayref, index, and value are popped\nfrom the operand stack. The int value is stored as the\ncomponent of the array indexed by index."
    },
    {
      "name": "iconst_<i>",
      "operation": "Push int constant",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "iconst_m1",
          "value": 2
        },
        {
          "name": "iconst_0",
          "value": 3
        },
        {
          "name": "iconst_1",
          "value": 4
        },
        {
          "name": "iconst_2",
          "value": 5
        },
        {
          "name": "iconst_3",
          "value": 6
        },
        {
          "name": "iconst_4",
          "value": 7
        },
        {
          "name": "iconst_5",
          "value": 8
        }
      ],
      "stack": "... \u2192 ..., <i>",
      "description": "Push the int constant <i> (-1, 0, 1, 2, 3, 4 or 5) onto the operand stack."
    },
    {
      "name": "idiv",
      "operation": "Divide int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "idiv",
          "value": 108
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. The values are\npopped from the operand stack. The int result is the value of\nthe Java programming language expression value1 / value2 (JLS \u00a715.17.2).\nThe result is pushed onto the operand stack.\nAn int division rounds towards 0; that is, the quotient produced\nfor int values in n/d is an int value q whose\nmagnitude is as large as possible while satisfying |d \u22c5\nq| \u2264 |n|. Moreover, q is positive when |n|\n\u2265 |d| and n and d have the same sign, but\nq is negative when |n| \u2265 |d| and n and\nd have opposite signs.\nThere is one special case that does not satisfy this rule: if the\ndividend is the negative integer of largest possible magnitude for\nthe int type, and the divisor is -1, then overflow occurs, and\nthe result is equal to the dividend. Despite the overflow, no\nexception is thrown in this case."
    },
    {
      "name": "if_acmp<cond>",
      "operation": "Branch if reference comparison succeeds",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2"
        ]
      ],
      "values": [
        {
          "name": "if_acmpeq",
          "value": 165
        },
        {
          "name": "if_acmpne",
          "value": 166
        }
      ],
      "stack": "..., value1, value2 \u2192 ...",
      "description": "Both value1 and value2 must be of type reference. They are both\npopped from the operand stack and compared. The results of the\ncomparison are as follows:\nif_acmpeq succeeds if and only if value1 = value2\nif_acmpne succeeds if and only if value1 \u2260 value2\nif_acmpeq succeeds if and only if value1 = value2\nif_acmpne succeeds if and only if value1 \u2260 value2\nif_acmpeq succeeds if and only if value1 = value2\nif_acmpne succeeds if and only if value1 \u2260 value2\nIf the comparison succeeds, the unsigned branchbyte1 and\nbranchbyte2 are used to construct a signed 16-bit offset, where\nthe offset is calculated to be (branchbyte1 << 8) |\nbranchbyte2. Execution then proceeds at that offset from the\naddress of the opcode of this if_acmp<cond> instruction. The\ntarget address must be that of an opcode of an instruction within\nthe method that contains this if_acmp<cond> instruction.\nOtherwise, if the comparison fails, execution proceeds at the\naddress of the instruction following this if_acmp<cond>\ninstruction."
    },
    {
      "name": "if_icmp<cond>",
      "operation": "Branch if int comparison succeeds",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2"
        ]
      ],
      "values": [
        {
          "name": "if_icmpeq",
          "value": 159
        },
        {
          "name": "if_icmpne",
          "value": 160
        },
        {
          "name": "if_icmplt",
          "value": 161
        },
        {
          "name": "if_icmpge",
          "value": 162
        },
        {
          "name": "if_icmpgt",
          "value": 163
        },
        {
          "name": "if_icmple",
          "value": 164
        }
      ],
      "stack": "..., value1, value2 \u2192 ...",
      "description": "Both value1 and value2 must be of type int. They are both\npopped from the operand stack and compared. All comparisons are\nsigned. The results of the comparison are as follows:\nif_icmpeq succeeds if and only if value1 = value2\nif_icmpne succeeds if and only if value1 \u2260 value2\nif_icmplt succeeds if and only if value1 < value2\nif_icmple succeeds if and only if value1 \u2264 value2\nif_icmpgt succeeds if and only if value1 > value2\nif_icmpge succeeds if and only if value1 \u2265 value2\nif_icmpeq succeeds if and only if value1 = value2\nif_icmpne succeeds if and only if value1 \u2260 value2\nif_icmplt succeeds if and only if value1 < value2\nif_icmple succeeds if and only if value1 \u2264 value2\nif_icmpgt succeeds if and only if value1 > value2\nif_icmpge succeeds if and only if value1 \u2265 value2\nif_icmpeq succeeds if and only if value1 = value2\nif_icmpne succeeds if and only if value1 \u2260 value2\nif_icmplt succeeds if and only if value1 < value2\nif_icmple succeeds if and only if value1 \u2264 value2\nif_icmpgt succeeds if and only if value1 > value2\nif_icmpge succeeds if and only if value1 \u2265 value2\nIf the comparison succeeds, the unsigned branchbyte1 and\nbranchbyte2 are used to construct a signed 16-bit offset, where\nthe offset is calculated to be (branchbyte1 << 8) |\nbranchbyte2. Execution then proceeds at that offset from the\naddress of the opcode of this if_icmp<cond> instruction. The\ntarget address must be that of an opcode of an instruction within\nthe method that contains this if_icmp<cond> instruction.\nOtherwise, execution proceeds at the address of the instruction\nfollowing this if_icmp<cond> instruction."
    },
    {
      "name": "if<cond>",
      "operation": "Branch if int comparison with zero succeeds",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2"
        ]
      ],
      "values": [
        {
          "name": "ifeq",
          "value": 153
        },
        {
          "name": "ifne",
          "value": 154
        },
        {
          "name": "iflt",
          "value": 155
        },
        {
          "name": "ifge",
          "value": 156
        },
        {
          "name": "ifgt",
          "value": 157
        },
        {
          "name": "ifle",
          "value": 158
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The value must be of type int. It is popped from the operand\nstack and compared against zero. All comparisons are signed. The\nresults of the comparisons are as follows:\nifeq succeeds if and only if value = 0\nifne succeeds if and only if value \u2260 0\niflt succeeds if and only if value < 0\nifle succeeds if and only if value \u2264 0\nifgt succeeds if and only if value > 0\nifge succeeds if and only if value \u2265 0\nifeq succeeds if and only if value = 0\nifne succeeds if and only if value \u2260 0\niflt succeeds if and only if value < 0\nifle succeeds if and only if value \u2264 0\nifgt succeeds if and only if value > 0\nifge succeeds if and only if value \u2265 0\nifeq succeeds if and only if value = 0\nifne succeeds if and only if value \u2260 0\niflt succeeds if and only if value < 0\nifle succeeds if and only if value \u2264 0\nifgt succeeds if and only if value > 0\nifge succeeds if and only if value \u2265 0\nIf the comparison succeeds, the unsigned branchbyte1 and\nbranchbyte2 are used to construct a signed 16-bit offset, where\nthe offset is calculated to be (branchbyte1 << 8) |\nbranchbyte2. Execution then proceeds at that offset from the\naddress of the opcode of this if<cond> instruction. The target\naddress must be that of an opcode of an instruction within the\nmethod that contains this if<cond> instruction.\nOtherwise, execution proceeds at the address of the instruction\nfollowing this if<cond> instruction."
    },
    {
      "name": "ifnonnull",
      "operation": "Branch if reference not null",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2"
        ]
      ],
      "values": [
        {
          "name": "ifnonnull",
          "value": 199
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The value must be of type reference. It is popped from the operand\nstack. If value is not null, the unsigned branchbyte1 and\nbranchbyte2 are used to construct a signed 16-bit offset, where\nthe offset is calculated to be (branchbyte1 << 8) |\nbranchbyte2. Execution then proceeds at that offset from the\naddress of the opcode of this ifnonnull instruction. The target\naddress must be that of an opcode of an instruction within the\nmethod that contains this ifnonnull instruction.\nOtherwise, execution proceeds at the address of the instruction\nfollowing this ifnonnull instruction."
    },
    {
      "name": "ifnull",
      "operation": "Branch if reference is null",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2"
        ]
      ],
      "values": [
        {
          "name": "ifnull",
          "value": 198
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The value must of type reference. It is popped from the operand\nstack. If value is null, the unsigned branchbyte1 and\nbranchbyte2 are used to construct a signed 16-bit offset, where\nthe offset is calculated to be (branchbyte1 << 8) |\nbranchbyte2. Execution then proceeds at that offset from the\naddress of the opcode of this ifnull instruction. The target\naddress must be that of an opcode of an instruction within the\nmethod that contains this ifnull instruction.\nOtherwise, execution proceeds at the address of the instruction\nfollowing this ifnull instruction."
    },
    {
      "name": "iinc",
      "operation": "Increment local variable by constant",
      "formats": [
        [
          "index",
          "const"
        ]
      ],
      "values": [
        {
          "name": "iinc",
          "value": 132
        }
      ],
      "stack": "No change",
      "description": "The index is an unsigned byte that must be an index into the\nlocal variable array of the current frame\n(\u00a72.6). The const is an\nimmediate signed byte. The local variable at index must contain\nan int. The value const is first\nsign-extended to an int, and then the local variable at index\nis incremented by that amount."
    },
    {
      "name": "iload",
      "operation": "Load int from local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "iload",
          "value": 21
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The index is an unsigned byte that must be an index into the\nlocal variable array of the current frame\n(\u00a72.6). The local variable at index must\ncontain an int. The value of the local variable at index is\npushed onto the operand stack."
    },
    {
      "name": "iload_<n>",
      "operation": "Load int from local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "iload_0",
          "value": 26
        },
        {
          "name": "iload_1",
          "value": 27
        },
        {
          "name": "iload_2",
          "value": 28
        },
        {
          "name": "iload_3",
          "value": 29
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The <n> must be an index into the local variable array\nof the current frame (\u00a72.6). The local\nvariable at <n> must contain an int. The value of\nthe local variable at <n> is pushed onto the operand\nstack."
    },
    {
      "name": "imul",
      "operation": "Multiply int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "imul",
          "value": 104
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. The values are\npopped from the operand stack. The int result is value1 *\nvalue2. The result is pushed onto the operand stack.\nThe result is the 32 low-order bits of the true mathematical\nresult in a sufficiently wide two's-complement format, represented\nas a value of type int. If overflow occurs, then the sign of the\nresult may not be the same as the sign of the\nmathematical multiplication of the two values.\nDespite the fact that overflow may occur, execution of an imul\ninstruction never throws a run-time exception."
    },
    {
      "name": "ineg",
      "operation": "Negate int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ineg",
          "value": 116
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value must be of type int. It is popped from the operand\nstack. The int result is the arithmetic negation of value,\n-value. The result is pushed onto the operand stack.\nFor int values, negation is the same as subtraction from\nzero. Because the Java Virtual Machine uses two's-complement representation for\nintegers and the range of two's-complement values is not\nsymmetric, the negation of the maximum negative int results in\nthat same maximum negative number. Despite the fact that overflow\nhas occurred, no exception is thrown.\nFor all int values x, -x\nequals (~x)+1."
    },
    {
      "name": "instanceof",
      "operation": "Determine if object is of given type",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "instanceof",
          "value": 193
        }
      ],
      "stack": "..., objectref \u2192 ..., result",
      "description": "The objectref, which must be of type reference, is popped from the\noperand stack. The unsigned indexbyte1 and indexbyte2 are used\nto construct an index into the run-time constant pool of the\ncurrent class (\u00a72.6), where the value of the\nindex is (indexbyte1 << 8) | indexbyte2. The run-time\nconstant pool entry at the index must be a symbolic reference to a\nclass, array, or interface type.\nIf objectref is null, the instanceof instruction pushes an\nint result of 0 as an int onto the operand stack.\nOtherwise, the named class, array, or interface type is resolved\n(\u00a75.4.3.1). If objectref is an instance of\nthe resolved class or array type, or implements the resolved\ninterface, the instanceof instruction pushes an int result\nof 1 as an int onto the operand stack; otherwise, it pushes an\nint result of 0.\nThe following rules are used to determine whether an objectref\nthat is not null is an instance of the resolved type. If S is\nthe type of the object referred to by objectref, and T is the\nresolved class, array, or interface type, then instanceof\ndetermines whether objectref is an instance of T as follows:\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by these run-time rules.\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by these run-time rules.\nIf S is a class type, then:\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf T is a class type, then S must be the same class as\nT, or S must be a subclass of T;\nIf T is an interface type, then S must implement\ninterface T.\nIf S is an array type SC[], that is, an array of\ncomponents of type SC, then:\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by these run-time rules.\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by these run-time rules.\nIf T is a class type, then T must be Object.\nIf T is an interface type, then T must be one of the\ninterfaces implemented by arrays (JLS \u00a74.10.3).\nIf T is an array type TC[], that is, an array\nof components of type TC, then one of the following must\nbe true:\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by these run-time rules.\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by these run-time rules.\nTC and SC are the same primitive type.\nTC and SC are reference types, and type SC can\nbe cast to TC by these run-time rules."
    },
    {
      "name": "invokedynamic",
      "operation": "Invoke a dynamically-computed call site",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2",
          "0",
          "0"
        ]
      ],
      "values": [
        {
          "name": "invokedynamic",
          "value": 186
        }
      ],
      "stack": "..., [arg1, [arg2 ...]] \u2192 ...",
      "description": "First, the unsigned indexbyte1 and indexbyte2 are used to\nconstruct an index into the run-time constant pool of the current\nclass (\u00a72.6), where the value of the index\nis (indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a\ndynamically-computed call site (\u00a75.1). The\nvalues of the third and fourth operand bytes must always be\nzero.\nThe symbolic reference is resolved (\u00a75.4.3.6)\nfor this specific invokedynamic\ninstruction to obtain a reference to an instance\nof java.lang.invoke.CallSite. The instance of java.lang.invoke.CallSite is considered \"bound\"\nto this specific invokedynamic instruction.\nThe instance of java.lang.invoke.CallSite indicates a target method\nhandle. The nargs argument values are popped from the\noperand stack, and the target method handle is invoked. The\ninvocation occurs as if by execution of an invokevirtual\ninstruction that indicates a run-time constant pool index to a\nsymbolic reference R where:\nR is a symbolic reference to a method of a class;\nfor the symbolic reference to the class in which the method is\nto be found, R specifies java.lang.invoke.MethodHandle;\nfor the name of the method, R specifies invokeExact;\nfor the descriptor of the method, R specifies the method\ndescriptor in the dynamically-computed call site.\nR is a symbolic reference to a method of a class;\nfor the symbolic reference to the class in which the method is\nto be found, R specifies java.lang.invoke.MethodHandle;\nfor the name of the method, R specifies invokeExact;\nfor the descriptor of the method, R specifies the method\ndescriptor in the dynamically-computed call site.\nR is a symbolic reference to a method of a class;\nfor the symbolic reference to the class in which the method is\nto be found, R specifies java.lang.invoke.MethodHandle;\nfor the name of the method, R specifies invokeExact;\nfor the descriptor of the method, R specifies the method\ndescriptor in the dynamically-computed call site.\nand where it is as if the following items were pushed, in order,\nonto the operand stack:\na reference to the target method handle;\nthe nargs argument values, where the number, type, and order\nof the values must be consistent with the method descriptor in\nthe dynamically-computed call site.\na reference to the target method handle;\nthe nargs argument values, where the number, type, and order\nof the values must be consistent with the method descriptor in\nthe dynamically-computed call site.\na reference to the target method handle;\nthe nargs argument values, where the number, type, and order\nof the values must be consistent with the method descriptor in\nthe dynamically-computed call site."
    },
    {
      "name": "invokeinterface",
      "operation": "Invoke interface method",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2",
          "count",
          "0"
        ]
      ],
      "values": [
        {
          "name": "invokeinterface",
          "value": 185
        }
      ],
      "stack": "..., objectref, [arg1, [arg2 ...]] \u2192 ...",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to an\ninterface method (\u00a75.1), which gives the\nname and descriptor (\u00a74.3.3) of the\ninterface method as well as a symbolic reference to the interface\nin which the interface method is to be found. The named interface\nmethod is resolved (\u00a75.4.3.4).\nThe resolved interface method must not be an instance\ninitialization method, or the class or interface initialization\nmethod (\u00a72.9.1,\n\u00a72.9.2).\nThe count operand is an unsigned byte that must not be zero. The\nobjectref must be of type reference and must be followed on the\noperand stack by nargs argument values, where the number, type,\nand order of the values must be consistent with the descriptor of\nthe resolved interface method. The value of the fourth operand\nbyte must always be zero.\nLet C be the class of objectref. A method is selected with\nrespect to C and the resolved method (\u00a75.4.6).\nThis is the method to be invoked.\nIf the method to be invoked is synchronized, the monitor\nassociated with objectref is entered or reentered as if by\nexecution of a monitorenter instruction\n(\u00a7monitorenter) in the current\nthread.\nIf the method to be invoked is not native, the nargs argument values and\nobjectref are popped from the operand stack. A new frame is\ncreated on the Java Virtual Machine stack for the method being invoked. The\nobjectref and the argument values are consecutively made the\nvalues of local variables of the new frame, with objectref in\nlocal variable 0, arg1 in local variable 1 (or, if arg1 is of\ntype long or double, in local variables 1 and 2), and so\non. The new frame is then made current,\nand the Java Virtual Machine pc is set to the opcode of the first instruction\nof the method to be invoked. Execution continues with the first\ninstruction of the method.\nIf the method to be invoked is native and the platform-dependent\ncode that implements it has not yet been bound\n(\u00a75.6) into the Java Virtual Machine, then that is\ndone. The nargs argument values and objectref are popped from\nthe operand stack and are passed as parameters to the code that\nimplements the method. The parameters are passed and the code is invoked in an\nimplementation-dependent manner. When the platform-dependent code\nreturns:\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current\tthread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current\tthread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current\tthread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack."
    },
    {
      "name": "invokespecial",
      "operation": "Invoke instance method; direct invocation of instance initialization\nmethods and methods of the current class and its supertypes",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "invokespecial",
          "value": 183
        }
      ],
      "stack": "..., objectref, [arg1, [arg2 ...]] \u2192 ...",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a method\nor an interface method (\u00a75.1), which gives\nthe name and descriptor (\u00a74.3.3) of the\nmethod or interface method as well as a symbolic reference to the\nclass or interface in which the method or interface method is to\nbe found. The named method is resolved\n(\u00a75.4.3.3, \u00a75.4.3.4).\nIf all of the following are true, let C be the direct superclass\nof the current class:\nThe resolved method is not an instance initialization method\n(\u00a72.9.1).\nThe symbolic reference names a class (not an interface),\nand that class is a superclass of the current class.\nThe ACC_SUPER flag is set for the class file\n(\u00a74.1).\nThe resolved method is not an instance initialization method\n(\u00a72.9.1).\nThe symbolic reference names a class (not an interface),\nand that class is a superclass of the current class.\nThe ACC_SUPER flag is set for the class file\n(\u00a74.1).\nThe resolved method is not an instance initialization method\n(\u00a72.9.1).\nThe symbolic reference names a class (not an interface),\nand that class is a superclass of the current class.\nThe ACC_SUPER flag is set for the class file\n(\u00a74.1).\nOtherwise, let C be the class or interface named by the\nsymbolic reference.\nThe actual method to be invoked is selected by the following\nlookup procedure:\nIf C contains a declaration for an instance method with the\nsame name and descriptor as the resolved method, then it is\nthe method to be invoked.\nOtherwise, if C is a class and has a superclass, a search\nfor a declaration of an instance method with the same name\nand descriptor as the resolved method is performed, starting\nwith the direct superclass of C and continuing with the\ndirect superclass of that class, and so forth, until a match\nis found or no further superclasses exist. If a match is\nfound, then it is the method to be invoked.\nOtherwise, if C is an interface and the class Object\ncontains a declaration of a public instance method with the\nsame name and descriptor as the resolved method, then it is\nthe method to be invoked.\nOtherwise, if there is exactly one maximally-specific method\n(\u00a75.4.3.3) in the superinterfaces of C\nthat matches the resolved method's name and descriptor and is\nnot abstract, then it is the method to be invoked.\nThe objectref must be of type reference and must be followed on the\noperand stack by nargs argument values, where the number, type,\nand order of the values must be consistent with the descriptor of\nthe selected instance method.\nIf the method is synchronized, the monitor associated with\nobjectref is entered or reentered as if by execution of a\nmonitorenter instruction\n(\u00a7monitorenter) in the current\nthread.\nIf the method is not native, the nargs argument values and\nobjectref are popped from the operand stack. A new frame is\ncreated on the Java Virtual Machine stack for the method being invoked. The\nobjectref and the argument values are consecutively made the\nvalues of local variables of the new frame, with objectref in\nlocal variable 0, arg1 in local variable 1 (or, if arg1 is of\ntype long or double, in local variables 1 and 2), and so\non. The new frame is then made current,\nand the Java Virtual Machine pc is set to the opcode of the first instruction\nof the method to be invoked. Execution continues with the first\ninstruction of the method.\nIf the method is native and the platform-dependent code that\nimplements it has not yet been bound (\u00a75.6)\ninto the Java Virtual Machine, that is done. The nargs argument values and\nobjectref are popped from the operand stack and are passed as\nparameters to the code that implements the method. The parameters are passed and the code is invoked in\nan implementation-dependent manner. When the platform-dependent\ncode returns, the following take place:\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current\nthread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current\nthread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current\nthread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack."
    },
    {
      "name": "invokestatic",
      "operation": "Invoke a class (static) method",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "invokestatic",
          "value": 184
        }
      ],
      "stack": "..., [arg1, [arg2 ...]] \u2192 ...",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a method\nor an interface method (\u00a75.1), which gives\nthe name and descriptor (\u00a74.3.3) of the\nmethod or interface method as well as a symbolic reference to the\nclass or interface in which the method or interface method is to\nbe found. The named method is resolved\n(\u00a75.4.3.3, \u00a75.4.3.4).\nThe resolved method must not be an instance initialization method,\nor the class or interface initialization method\n(\u00a72.9.1, \u00a72.9.2).\nThe resolved method must be static, and therefore cannot be\nabstract.\nOn successful resolution of the method, the class or interface\nthat declared the resolved method is initialized if that class or\ninterface has not already been initialized\n(\u00a75.5).\nThe operand stack must contain nargs argument values, where the\nnumber, type, and order of the values must be consistent with the\ndescriptor of the resolved method.\nIf the method is synchronized, the monitor associated with the\nresolved Class object is entered or reentered as if by execution\nof a monitorenter instruction\n(\u00a7monitorenter) in the current\nthread.\nIf the method is not native, the nargs argument values are\npopped from the operand stack. A new frame is created on the Java Virtual Machine\nstack for the method being invoked. The nargs argument values\nare consecutively made the values of local variables of the new\nframe, with arg1 in local variable 0 (or, if arg1 is of type\nlong or double, in local variables 0 and 1) and so on. The new frame is then made current,\nand the Java Virtual Machine pc is set to the opcode of the first instruction\nof the method to be invoked. Execution continues with the first\ninstruction of the method.\nIf the method is native and the platform-dependent code that\nimplements it has not yet been bound (\u00a75.6)\ninto the Java Virtual Machine, that is done. The nargs argument values are\npopped from the operand stack and are passed as parameters to the\ncode that implements the method. The parameters are passed and the code is invoked in an\nimplementation-dependent manner. When the platform-dependent code\nreturns, the following take place:\nIf the native method is synchronized, the monitor\nassociated with the resolved Class object is updated and\npossibly exited as if by execution of a monitorexit\ninstruction (\u00a7monitorexit) in the\ncurrent thread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the native method is synchronized, the monitor\nassociated with the resolved Class object is updated and\npossibly exited as if by execution of a monitorexit\ninstruction (\u00a7monitorexit) in the\ncurrent thread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the native method is synchronized, the monitor\nassociated with the resolved Class object is updated and\npossibly exited as if by execution of a monitorexit\ninstruction (\u00a7monitorexit) in the\ncurrent thread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack."
    },
    {
      "name": "invokevirtual",
      "operation": "Invoke instance method; dispatch based on class",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "invokevirtual",
          "value": 182
        }
      ],
      "stack": "..., objectref, [arg1, [arg2 ...]] \u2192 ...",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a method\n(\u00a75.1), which gives the name and descriptor\n(\u00a74.3.3) of the method as well as a symbolic\nreference to the class in which the method is to be found. The\nnamed method is resolved (\u00a75.4.3.3).\nIf the resolved method is not signature polymorphic\n(\u00a72.9.3), then the invokevirtual instruction\nproceeds as follows.\nLet C be the class of objectref. A method is selected with\nrespect to C and the resolved method (\u00a75.4.6).\nThis is the method to be invoked.\nThe objectref must be followed on the operand stack by nargs\nargument values, where the number, type, and order of the values\nmust be consistent with the descriptor of the selected instance\nmethod.\nIf the method to be invoked is synchronized, the monitor\nassociated with objectref is entered or reentered as if by\nexecution of a monitorenter instruction\n(\u00a7monitorenter) in the current\nthread.\nIf the method to be invoked is not native, the nargs argument\nvalues and objectref are popped from the operand stack. A new\nframe is created on the Java Virtual Machine stack for the method being\ninvoked. The objectref and the argument values are consecutively\nmade the values of local variables of the new frame, with\nobjectref in local variable 0, arg1 in local variable 1 (or,\nif arg1 is of type long or double, in local variables 1 and\n2), and so on. The new frame is\nthen made current, and the Java Virtual Machine pc is set to the opcode of the\nfirst instruction of the method to be invoked. Execution continues\nwith the first instruction of the method.\nIf the method to be invoked is native and the platform-dependent\ncode that implements it has not yet been bound (\u00a75.6) into the Java Virtual Machine, that is done. The nargs\nargument values and objectref are popped from the operand stack\nand are passed as parameters to the code that implements the\nmethod. The parameters are\npassed and the code is invoked in an implementation-dependent\nmanner. When the platform-dependent code returns, the following\ntake place:\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current thread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current thread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the native method is synchronized, the monitor\nassociated with objectref is updated and possibly exited as\nif by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current thread.\nIf the native method returns a value, the return value of\nthe platform-dependent code is converted in an\nimplementation-dependent way to the return type of the\nnative method and pushed onto the operand stack.\nIf the resolved method is signature polymorphic\n(\u00a72.9.3),\nand declared in the java.lang.invoke.MethodHandle class,\nthen the invokevirtual instruction proceeds as follows, where D is\nthe descriptor of the method symbolically referenced by the instruction.\nFirst, a reference to an instance of java.lang.invoke.MethodType is obtained as if by\nresolution of a symbolic reference to a method type\n(\u00a75.4.3.5) with the same parameter and\nreturn types as D.\nIf the named method is invokeExact, the instance of\njava.lang.invoke.MethodType must be semantically equal to the type descriptor\nof the receiving method handle objectref. The\nmethod handle to be invoked is objectref.\nIf the named method is invoke, and the instance of\njava.lang.invoke.MethodType is semantically equal to the type descriptor of\nthe receiving method handle objectref, then\nthe method handle to be invoked is objectref.\nIf the named method is invoke, and the instance of\njava.lang.invoke.MethodType is not semantically equal to the type descriptor\nof the receiving method handle objectref, then the Java Virtual Machine\nattempts to adjust the type descriptor of the receiving method\nhandle, as if by invocation of the asType method of java.lang.invoke.MethodHandle,\nto obtain an exactly invokable method handle m. The\nmethod handle to be invoked is m.\nIf the named method is invokeExact, the instance of\njava.lang.invoke.MethodType must be semantically equal to the type descriptor\nof the receiving method handle objectref. The\nmethod handle to be invoked is objectref.\nIf the named method is invoke, and the instance of\njava.lang.invoke.MethodType is semantically equal to the type descriptor of\nthe receiving method handle objectref, then\nthe method handle to be invoked is objectref.\nIf the named method is invoke, and the instance of\njava.lang.invoke.MethodType is not semantically equal to the type descriptor\nof the receiving method handle objectref, then the Java Virtual Machine\nattempts to adjust the type descriptor of the receiving method\nhandle, as if by invocation of the asType method of java.lang.invoke.MethodHandle,\nto obtain an exactly invokable method handle m. The\nmethod handle to be invoked is m.\nIf the named method is invokeExact, the instance of\njava.lang.invoke.MethodType must be semantically equal to the type descriptor\nof the receiving method handle objectref. The\nmethod handle to be invoked is objectref.\nIf the named method is invoke, and the instance of\njava.lang.invoke.MethodType is semantically equal to the type descriptor of\nthe receiving method handle objectref, then\nthe method handle to be invoked is objectref.\nIf the named method is invoke, and the instance of\njava.lang.invoke.MethodType is not semantically equal to the type descriptor\nof the receiving method handle objectref, then the Java Virtual Machine\nattempts to adjust the type descriptor of the receiving method\nhandle, as if by invocation of the asType method of java.lang.invoke.MethodHandle,\nto obtain an exactly invokable method handle m. The\nmethod handle to be invoked is m.\nThe objectref must be followed on the operand stack by nargs\nargument values, where the number, type, and order of the values\nmust be consistent with the type descriptor of the method handle\nto be invoked. (This type descriptor will correspond to the method\ndescriptor appropriate for the kind of the method handle to be\ninvoked, as specified in \u00a75.4.3.5.)\nThen, if the method handle to be invoked has bytecode behavior,\nthe Java Virtual Machine invokes the method handle as if by execution of the\nbytecode behavior associated with the method handle's kind. If the\nkind is 5 (REF_invokeVirtual), 6 (REF_invokeStatic), 7\n(REF_invokeSpecial), 8 (REF_newInvokeSpecial), or 9\n(REF_invokeInterface), then a frame will be created and made\ncurrent in the course of executing the bytecode\nbehavior; however, this frame is not visible, and when\nthe method invoked by the bytecode behavior completes (normally or\nabruptly), the frame of its invoker is\nconsidered to be the frame for the method containing this\ninvokevirtual instruction.\nOtherwise, if the method handle to be invoked has no bytecode\nbehavior, the Java Virtual Machine invokes it in an implementation-dependent\nmanner.\nIf the resolved method is signature polymorphic and\ndeclared in the java.lang.invoke.VarHandle class, then the\ninvokevirtual instruction proceeds as follows, where N and\nD are the name and descriptor of the method symbolically\nreferenced by the instruction.\nFirst, a reference to an instance of java.lang.invoke.VarHandle.AccessMode is obtained\nas if by invocation of the valueFromMethodName method\nof java.lang.invoke.VarHandle.AccessMode with a String argument denoting N.\nSecond, a reference to an instance of java.lang.invoke.MethodType is obtained as if\nby invocation of the accessModeType method of java.lang.invoke.VarHandle\non the instance objectref, with the instance of\njava.lang.invoke.VarHandle.AccessMode as the argument.\nThird, a reference to an instance of java.lang.invoke.MethodHandle is obtained as if\nby invocation of the varHandleExactInvoker method of java.lang.invoke.MethodHandles\nwith the instance of java.lang.invoke.VarHandle.AccessMode as the first argument\nand the instance of java.lang.invoke.MethodType as the second argument. The resulting\ninstance is called the invoker method handle.\nFinally, the nargs argument values and objectref are popped\nfrom the operand stack, and the invoker method handle is\ninvoked. The invocation occurs as if by execution of an\ninvokevirtual instruction that indicates a run-time constant\npool index to a symbolic reference R where:\nR is a symbolic reference to a method of a class;\nfor the symbolic reference to the class in which the method is\nto be found, R specifies java.lang.invoke.MethodHandle;\nfor the name of the method, R specifies invoke;\nfor the descriptor of the method, R specifies a return type\nindicated by the return descriptor of D, and specifies a\nfirst parameter type of java.lang.invoke.VarHandle followed by the parameter\ntypes indicated by the parameter descriptors of D (if any)\nin order.\nR is a symbolic reference to a method of a class;\nfor the symbolic reference to the class in which the method is\nto be found, R specifies java.lang.invoke.MethodHandle;\nfor the name of the method, R specifies invoke;\nfor the descriptor of the method, R specifies a return type\nindicated by the return descriptor of D, and specifies a\nfirst parameter type of java.lang.invoke.VarHandle followed by the parameter\ntypes indicated by the parameter descriptors of D (if any)\nin order.\nR is a symbolic reference to a method of a class;\nfor the symbolic reference to the class in which the method is\nto be found, R specifies java.lang.invoke.MethodHandle;\nfor the name of the method, R specifies invoke;\nfor the descriptor of the method, R specifies a return type\nindicated by the return descriptor of D, and specifies a\nfirst parameter type of java.lang.invoke.VarHandle followed by the parameter\ntypes indicated by the parameter descriptors of D (if any)\nin order.\nand where it is as if the following items were pushed, in order,\nonto the operand stack:\na reference to the instance of java.lang.invoke.MethodHandle (the invoker method handle);\nobjectref;\nthe nargs argument values, where the number, type, and order\nof the values must be consistent with the type descriptor of\nthe invoker method handle.\na reference to the instance of java.lang.invoke.MethodHandle (the invoker method handle);\nobjectref;\nthe nargs argument values, where the number, type, and order\nof the values must be consistent with the type descriptor of\nthe invoker method handle.\na reference to the instance of java.lang.invoke.MethodHandle (the invoker method handle);\nobjectref;\nthe nargs argument values, where the number, type, and order\nof the values must be consistent with the type descriptor of\nthe invoker method handle."
    },
    {
      "name": "ior",
      "operation": "Boolean OR int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ior",
          "value": 128
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. They are popped\nfrom the operand stack. An int result is calculated by taking\nthe bitwise inclusive OR of value1 and value2. The result is\npushed onto the operand stack."
    },
    {
      "name": "irem",
      "operation": "Remainder int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "irem",
          "value": 112
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. The values are\npopped from the operand stack. The int result is value1 -\n(value1 / value2) * value2. The result is pushed onto the\noperand stack.\nThe result of the irem instruction is such that (a/b)*b\n+ (a%b) is equal to a. This identity\nholds even in the special case in which the dividend is the\nnegative int of largest possible magnitude for its type and the\ndivisor is -1 (the remainder is 0). It follows from this rule that\nthe result of the remainder operation can be negative only if the\ndividend is negative and can be positive only if the dividend is\npositive. Moreover, the magnitude of the result is always less\nthan the magnitude of the divisor."
    },
    {
      "name": "ireturn",
      "operation": "Return int from method",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ireturn",
          "value": 172
        }
      ],
      "stack": "..., value \u2192 [empty]",
      "description": "The current method must have return type boolean, byte,\nchar, short, or int. The value must be of type int. If\nthe current method is a synchronized method, the monitor entered\nor reentered on invocation of the method is updated and possibly\nexited as if by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current thread. If\nno exception is thrown, value is popped from the operand stack\nof the current frame (\u00a72.6) and pushed onto\nthe operand stack of the frame of the invoker. Any other values on\nthe operand stack of the current method are discarded.\nPrior to pushing value onto the operand stack of the frame of\nthe invoker, it may have to be converted. If the return type of\nthe invoked method was byte, char, or short, then value is\nconverted from int to the return type as if by execution of\ni2b, i2c, or i2s, respectively. If the return type of the\ninvoked method was boolean, then value is narrowed from int to\nboolean by taking the bitwise AND of value and 1.\nThe interpreter then returns control to the invoker of the method,\nreinstating the frame of the invoker."
    },
    {
      "name": "ishl",
      "operation": "Shift left int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ishl",
          "value": 120
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. The values are\npopped from the operand stack. An int result is calculated by\nshifting value1 left by s bit positions, where s is\nthe value of the low 5 bits of value2. The result is pushed\nonto the operand stack."
    },
    {
      "name": "ishr",
      "operation": "Arithmetic shift right int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ishr",
          "value": 122
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. The values are\npopped from the operand stack. An int result is calculated by\nshifting value1 right by s bit positions, with sign\nextension, where s is the value of the low 5 bits of\nvalue2. The result is pushed onto the operand stack."
    },
    {
      "name": "istore",
      "operation": "Store int into local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "istore",
          "value": 54
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The index is an unsigned byte that must be an index into the\nlocal variable array of the current frame\n(\u00a72.6). The value on the top of the\noperand stack must be of type int. It is popped from the operand\nstack, and the value of the local variable at index is set to\nvalue."
    },
    {
      "name": "istore_<n>",
      "operation": "Store int into local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "istore_0",
          "value": 59
        },
        {
          "name": "istore_1",
          "value": 60
        },
        {
          "name": "istore_2",
          "value": 61
        },
        {
          "name": "istore_3",
          "value": 62
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The <n> must be an index into the local variable array\nof the current frame (\u00a72.6). The value on\nthe top of the operand stack must be of type int. It is popped\nfrom the operand stack, and the value of the local variable at\n<n> is set to value."
    },
    {
      "name": "isub",
      "operation": "Subtract int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "isub",
          "value": 100
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. The values are\npopped from the operand stack. The int result is value1 -\nvalue2. The result is pushed onto the operand stack.\nFor int subtraction, a-b produces the same\nresult as a+(-b). For int values, subtraction\nfrom zero is the same as negation.\nThe result is the 32 low-order bits of the true mathematical\nresult in a sufficiently wide two's-complement format, represented\nas a value of type int. If overflow occurs, then the sign of the\nresult may not be the same as the sign of the mathematical\ndifference of the two values.\nDespite the fact that overflow may occur, execution of an isub\ninstruction never throws a run-time exception."
    },
    {
      "name": "iushr",
      "operation": "Logical shift right int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "iushr",
          "value": 124
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. The values are\npopped from the operand stack. An int result is calculated by\nshifting value1 right by s bit positions, with zero\nextension, where s is the value of the low 5 bits of\nvalue2. The result is pushed onto the operand stack."
    },
    {
      "name": "ixor",
      "operation": "Boolean XOR int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ixor",
          "value": 130
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type int. They are popped\nfrom the operand stack. An int result is calculated by taking\nthe bitwise exclusive OR of value1 and value2. The result is\npushed onto the operand stack."
    },
    {
      "name": "jsr",
      "operation": "Jump subroutine",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2"
        ]
      ],
      "values": [
        {
          "name": "jsr",
          "value": 168
        }
      ],
      "stack": "... \u2192 ..., address",
      "description": "The address of the opcode of the instruction immediately\nfollowing this jsr instruction is pushed onto the operand stack\nas a value of type returnAddress. The unsigned branchbyte1 and\nbranchbyte2 are used to construct a signed 16-bit offset, where\nthe offset is (branchbyte1 << 8) |\nbranchbyte2. Execution proceeds at that offset from the address\nof this jsr instruction. The target address must be that of an\nopcode of an instruction within the method that contains this\njsr instruction."
    },
    {
      "name": "jsr_w",
      "operation": "Jump subroutine (wide index)",
      "formats": [
        [
          "branchbyte1",
          "branchbyte2",
          "branchbyte3",
          "branchbyte4"
        ]
      ],
      "values": [
        {
          "name": "jsr_w",
          "value": 201
        }
      ],
      "stack": "... \u2192 ..., address",
      "description": "The address of the opcode of the instruction immediately\nfollowing this jsr_w instruction is pushed onto the operand\nstack as a value of type returnAddress. The unsigned\nbranchbyte1, branchbyte2, branchbyte3, and branchbyte4 are\nused to construct a signed 32-bit offset, where the offset is\n(branchbyte1 << 24) | (branchbyte2 << 16) |\n(branchbyte3 << 8) | branchbyte4. Execution proceeds at\nthat offset from the address of this jsr_w instruction. The\ntarget address must be that of an opcode of an instruction within\nthe method that contains this jsr_w instruction."
    },
    {
      "name": "l2d",
      "operation": "Convert long to double",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "l2d",
          "value": 138
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nlong. It is popped from the operand stack and converted to a\ndouble result using the\nround to nearest rounding policy (\u00a72.8).\nThe result is pushed onto the operand stack."
    },
    {
      "name": "l2f",
      "operation": "Convert long to float",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "l2f",
          "value": 137
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nlong. It is popped from the operand stack and converted to a\nfloat result using the\nround to nearest rounding policy (\u00a72.8).\nThe result is pushed onto the operand stack."
    },
    {
      "name": "l2i",
      "operation": "Convert long to int",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "l2i",
          "value": 136
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value on the top of the operand stack must be of type\nlong. It is popped from the operand stack and converted to an\nint result by taking the low-order 32 bits of the long value\nand discarding the high-order 32 bits. The result is pushed onto\nthe operand stack."
    },
    {
      "name": "ladd",
      "operation": "Add long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ladd",
          "value": 97
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. The values are\npopped from the operand stack. The long result is value1 +\nvalue2. The result is pushed onto the operand stack.\nThe result is the 64 low-order bits of the true mathematical\nresult in a sufficiently wide two's-complement format, represented\nas a value of type long. If overflow occurs, the sign of the\nresult may not be the same as the sign of the mathematical sum of\nthe two values.\nDespite the fact that overflow may occur, execution of an ladd\ninstruction never throws a run-time exception."
    },
    {
      "name": "laload",
      "operation": "Load long from array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "laload",
          "value": 47
        }
      ],
      "stack": "..., arrayref, index \u2192 ..., value",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type long. The index must be of type\nint. Both arrayref and index are popped from the operand\nstack. The long value in the component of the array at index\nis retrieved and pushed onto the operand stack."
    },
    {
      "name": "land",
      "operation": "Boolean AND long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "land",
          "value": 127
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. They are popped\nfrom the operand stack. A long result is calculated by taking\nthe bitwise AND of value1 and value2. The result is pushed\nonto the operand stack."
    },
    {
      "name": "lastore",
      "operation": "Store into long array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lastore",
          "value": 80
        }
      ],
      "stack": "..., arrayref, index, value \u2192 ...",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type long. The index must be of type\nint, and value must be of type long. The arrayref,\nindex, and value are popped from the operand stack. The long\nvalue is stored as the component of the array indexed by\nindex."
    },
    {
      "name": "lcmp",
      "operation": "Compare long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lcmp",
          "value": 148
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. They are both\npopped from the operand stack, and a signed integer comparison is\nperformed. If value1 is greater than value2, the int value 1\nis pushed onto the operand stack. If value1 is equal to\nvalue2, the int value 0 is pushed onto the operand stack. If\nvalue1 is less than value2, the int value -1 is pushed onto\nthe operand stack."
    },
    {
      "name": "lconst_<l>",
      "operation": "Push long constant",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lconst_0",
          "value": 9
        },
        {
          "name": "lconst_1",
          "value": 10
        }
      ],
      "stack": "... \u2192 ..., <l>",
      "description": "Push the long constant <l> (0 or 1) onto the operand stack."
    },
    {
      "name": "ldc",
      "operation": "Push item from run-time constant pool",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "ldc",
          "value": 18
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The index is an unsigned byte that must be a valid index into\nthe run-time constant pool of the current class\n(\u00a72.5.5). The run-time constant pool entry\nat index must be\nloadable (\u00a75.1), and not any of the following:\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nIf the run-time constant pool entry is a numeric constant of type\nint or float, then the value of that numeric constant is\npushed onto the operand stack as an int or float, respectively.\nOtherwise, if the run-time constant pool entry is a string\nconstant, that is, a reference to an instance of class String, then\nvalue, a reference to that instance, is pushed onto the operand stack.\nOtherwise, if the run-time constant pool entry is a symbolic\nreference to a class or interface, then the named class or\ninterface is resolved (\u00a75.4.3.1) and\nvalue, a reference to the Class object representing that class or\ninterface, is pushed onto the operand stack.\nOtherwise, the run-time constant pool entry is a symbolic\nreference to a method type, a method handle, or a\ndynamically-computed constant. The symbolic reference is resolved\n(\u00a75.4.3.5, \u00a75.4.3.6)\nand value, the result of resolution, is pushed onto the operand\nstack."
    },
    {
      "name": "ldc_w",
      "operation": "Push item from run-time constant pool (wide index)",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "ldc_w",
          "value": 19
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The unsigned indexbyte1 and indexbyte2 are assembled into an\nunsigned 16-bit index into the run-time constant pool of the\ncurrent class (\u00a72.5.5), where the value of the\nindex is calculated as (indexbyte1 << 8) | indexbyte2.\nThe index must be a valid index into the run-time constant pool of\nthe current class. The run-time constant pool entry at the\nindex must be loadable\n(\u00a75.1), and not any of the following:\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nIf the run-time constant pool entry is a numeric constant of type\nint or float, or a string constant, then value is determined\nand pushed onto the operand stack according to the rules given for\nthe ldc instruction.\nOtherwise, the run-time constant pool entry is a symbolic\nreference to a class, interface, method type, method handle, or\ndynamically-computed constant. It is resolved and value is\ndetermined and pushed onto the operand stack according to the\nrules given for the ldc instruction."
    },
    {
      "name": "ldc2_w",
      "operation": "Push long or double from run-time constant pool (wide index)",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "ldc2_w",
          "value": 20
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The unsigned indexbyte1 and indexbyte2 are assembled into an\nunsigned 16-bit index into the run-time constant pool of the\ncurrent class (\u00a72.5.5), where the value of\nthe index is calculated as (indexbyte1 << 8) |\nindexbyte2. The index must be a valid index into the run-time\nconstant pool of the current class. The run-time constant pool\nentry at the index must be loadable (\u00a75.1),\nand in particular one of the following:\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nA numeric constant of type long or double.\nA symbolic reference to a dynamically-computed constant whose\nfield descriptor is J (denoting long) or\nD (denoting double).\nIf the run-time constant pool entry is a numeric constant of type\nlong or double, then the value of that numeric constant is\npushed onto the operand stack as a long or double, respectively.\nOtherwise, the run-time constant pool entry is a symbolic\nreference to a dynamically-computed constant. The symbolic\nreference is resolved (\u00a75.4.3.6) and\nvalue, the result of resolution, is pushed onto the operand stack."
    },
    {
      "name": "ldiv",
      "operation": "Divide long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "ldiv",
          "value": 109
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. The values are\npopped from the operand stack. The long result is the value of\nthe Java programming language expression value1 / value2. The result is\npushed onto the operand stack.\nA long division rounds towards 0; that is, the quotient produced\nfor long values in n / d is a long value q\nwhose magnitude is as large as possible while satisfying |d\n\u22c5 q| \u2264 |n|. Moreover, q is positive when\n|n| \u2265 |d| and n and d have the same sign,\nbut q is negative when |n| \u2265 |d| and n and\nd have opposite signs.\nThere is one special case that does not satisfy this rule: if the\ndividend is the negative integer of largest possible magnitude for\nthe long type and the divisor is -1, then overflow occurs and\nthe result is equal to the dividend; despite the overflow, no\nexception is thrown in this case."
    },
    {
      "name": "lload",
      "operation": "Load long from local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "lload",
          "value": 22
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The index is an unsigned byte. Both index and index+1 must\nbe indices into the local variable array of the current frame\n(\u00a72.6). The local variable at index must\ncontain a long. The value of the local variable at index is\npushed onto the operand stack."
    },
    {
      "name": "lload_<n>",
      "operation": "Load long from local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lload_0",
          "value": 30
        },
        {
          "name": "lload_1",
          "value": 31
        },
        {
          "name": "lload_2",
          "value": 32
        },
        {
          "name": "lload_3",
          "value": 33
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "Both <n> and <n>+1 must be indices into the\nlocal variable array of the current frame\n(\u00a72.6). The local variable at <n>\nmust contain a long. The value of the local variable at\n<n> is pushed onto the operand stack."
    },
    {
      "name": "lmul",
      "operation": "Multiply long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lmul",
          "value": 105
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. The values are\npopped from the operand stack. The long result is value1 *\nvalue2. The result is pushed onto the operand stack.\nThe result is the 64 low-order bits of the true mathematical\nresult in a sufficiently wide two's-complement format, represented\nas a value of type long. If overflow occurs, the sign of the\nresult may not be the same as the sign of the\nmathematical multiplication of the two values.\nDespite the fact that overflow may occur, execution of an lmul\ninstruction never throws a run-time exception."
    },
    {
      "name": "lneg",
      "operation": "Negate long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lneg",
          "value": 117
        }
      ],
      "stack": "..., value \u2192 ..., result",
      "description": "The value must be of type long. It is popped from the operand\nstack. The long result is the arithmetic negation of value,\n-value. The result is pushed onto the operand stack.\nFor long values, negation is the same as subtraction from\nzero. Because the Java Virtual Machine uses two's-complement representation for\nintegers and the range of two's-complement values is not\nsymmetric, the negation of the maximum negative long results in\nthat same maximum negative number. Despite the fact that overflow\nhas occurred, no exception is thrown.\nFor all long values x, -x\nequals (~x)+1."
    },
    {
      "name": "lookupswitch",
      "operation": "Access jump table by key match and jump",
      "formats": [
        [
          "<0-3\u00a0byte\u00a0pad>",
          "defaultbyte1",
          "defaultbyte2",
          "defaultbyte3",
          "defaultbyte4",
          "npairs1",
          "npairs2",
          "npairs3",
          "npairs4",
          "match-offset\u00a0pairs..."
        ]
      ],
      "values": [
        {
          "name": "lookupswitch",
          "value": 171
        }
      ],
      "stack": "..., key \u2192 ...",
      "description": "A lookupswitch is a variable-length instruction. Immediately\nafter the lookupswitch opcode, between zero and three bytes must\nact as padding, such that defaultbyte1 begins\nat an address that is a multiple of four bytes from the start of\nthe current method (the opcode of its first\ninstruction). Immediately after the padding follow a series of\nsigned 32-bit\nvalues: default, npairs,\nand then npairs pairs of signed 32-bit\nvalues. The npairs must be greater than or\nequal to 0. Each of the npairs pairs consists\nof an int match and a signed\n32-bit offset. Each of these signed 32-bit\nvalues is constructed from four unsigned bytes as\n(byte1 << 24) |\n(byte2 << 16) |\n(byte3 << 8)\n| byte4.\nThe table match-offset pairs of the\nlookupswitch instruction must be sorted in increasing numerical\norder by match.\nThe key must be of type int and is popped\nfrom the operand stack. The key is compared\nagainst the match values. If it is equal to\none of them, then a target address is calculated by adding the\ncorresponding offset to the address of the\nopcode of this lookupswitch instruction. If\nthe key does not match any of\nthe match values, the target address is\ncalculated by adding default to the address\nof the opcode of this lookupswitch instruction. Execution then\ncontinues at the target address.\nThe target address that can be calculated from the\noffset of\neach match-offset pair, as well as the one\ncalculated from default, must be the address\nof an opcode of an instruction within the method that contains\nthis lookupswitch instruction."
    },
    {
      "name": "lor",
      "operation": "Boolean OR long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lor",
          "value": 129
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. They are popped\nfrom the operand stack. A long result is calculated by taking\nthe bitwise inclusive OR of value1 and value2. The result is\npushed onto the operand stack."
    },
    {
      "name": "lrem",
      "operation": "Remainder long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lrem",
          "value": 113
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. The values are\npopped from the operand stack. The long result is value1 -\n(value1 / value2) * value2. The result is pushed onto the\noperand stack.\nThe result of the lrem instruction is such that\n(a/b)*b + (a%b) is equal\nto a. This identity holds even in the special\ncase in which the dividend is the negative long of largest\npossible magnitude for its type and the divisor is -1 (the\nremainder is 0). It follows from this rule that the result of the\nremainder operation can be negative only if the dividend is\nnegative and can be positive only if the dividend is positive;\nmoreover, the magnitude of the result is always less than the\nmagnitude of the divisor."
    },
    {
      "name": "lreturn",
      "operation": "Return long from method",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lreturn",
          "value": 173
        }
      ],
      "stack": "..., value \u2192 [empty]",
      "description": "The current method must have return type long. The value must\nbe of type long. If the current method is a synchronized\nmethod, the monitor entered or reentered on invocation of the\nmethod is updated and possibly exited as if by execution of a\nmonitorexit instruction (\u00a7monitorexit)\nin the current thread. If no exception is thrown, value is\npopped from the operand stack of the current frame\n(\u00a72.6) and pushed onto the operand stack of\nthe frame of the invoker. Any other values on the operand stack of\nthe current method are discarded.\nThe interpreter then returns control to the invoker of the method,\nreinstating the frame of the invoker."
    },
    {
      "name": "lshl",
      "operation": "Shift left long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lshl",
          "value": 121
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "The value1 must be of type long, and value2 must be of type\nint. The values are popped from the operand stack. A long\nresult is calculated by shifting value1 left by s bit\npositions, where s is the low 6 bits of value2. The\nresult is pushed onto the operand stack."
    },
    {
      "name": "lshr",
      "operation": "Arithmetic shift right long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lshr",
          "value": 123
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "The value1 must be of type long, and value2 must be of type\nint. The values are popped from the operand stack. A long\nresult is calculated by shifting value1 right by s bit\npositions, with sign extension, where s is the value of the\nlow 6 bits of value2. The result is pushed onto the operand\nstack."
    },
    {
      "name": "lstore",
      "operation": "Store long into local variable",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "lstore",
          "value": 55
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The index is an unsigned byte. Both index and index+1 must\nbe indices into the local variable array of the current frame\n(\u00a72.6). The value on the top of the\noperand stack must be of type long. It is popped from the\noperand stack, and the local variables at index and index+1\nare set to value."
    },
    {
      "name": "lstore_<n>",
      "operation": "Store long into local variable",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lstore_0",
          "value": 63
        },
        {
          "name": "lstore_1",
          "value": 64
        },
        {
          "name": "lstore_2",
          "value": 65
        },
        {
          "name": "lstore_3",
          "value": 66
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "Both <n> and <n>+1 must be indices into the\nlocal variable array of the current frame\n(\u00a72.6). The value on the top of the\noperand stack must be of type long. It is popped from the\noperand stack, and the local variables at <n> and\n<n>+1 are set to value."
    },
    {
      "name": "lsub",
      "operation": "Subtract long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lsub",
          "value": 101
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. The values are\npopped from the operand stack. The long result is value1 -\nvalue2. The result is pushed onto the operand stack.\nFor long subtraction, a-b produces the same\nresult as a+(-b). For long values,\nsubtraction from zero is the same as negation.\nThe result is the 64 low-order bits of the true mathematical\nresult in a sufficiently wide two's-complement format, represented\nas a value of type long. If overflow occurs, then the sign of\nthe result may not be the same as the sign of the\nmathematical difference of the two values.\nDespite the fact that overflow may occur, execution of an lsub\ninstruction never throws a run-time exception."
    },
    {
      "name": "lushr",
      "operation": "Logical shift right long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lushr",
          "value": 125
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "The value1 must be of type long, and value2 must be of type\nint. The values are popped from the operand stack. A long\nresult is calculated by shifting value1 right\nlogically by s bit positions, with zero\nextension, where s is the value of the low 6 bits of\nvalue2. The result is pushed onto the operand stack."
    },
    {
      "name": "lxor",
      "operation": "Boolean XOR long",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "lxor",
          "value": 131
        }
      ],
      "stack": "..., value1, value2 \u2192 ..., result",
      "description": "Both value1 and value2 must be of type long. They are popped\nfrom the operand stack. A long result is calculated by taking\nthe bitwise exclusive OR of value1 and value2. The result is\npushed onto the operand stack."
    },
    {
      "name": "monitorenter",
      "operation": "Enter monitor for object",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "monitorenter",
          "value": 194
        }
      ],
      "stack": "..., objectref \u2192 ...",
      "description": "The objectref must be of type reference.\nEach object is associated with a monitor. A monitor is locked if\nand only if it has an owner. The thread that executes\nmonitorenter attempts to gain ownership of the monitor\nassociated with objectref, as follows:\nIf the entry count of the monitor associated with objectref\nis zero, the thread enters the monitor and sets its entry\ncount to one. The thread is then the owner of the\nmonitor.\nIf the thread already owns the monitor associated with\nobjectref, it reenters the monitor, incrementing its entry\ncount.\nIf another thread already owns the monitor associated with\nobjectref, the thread blocks until the monitor's entry count\nis zero, then tries again to gain ownership.\nIf the entry count of the monitor associated with objectref\nis zero, the thread enters the monitor and sets its entry\ncount to one. The thread is then the owner of the\nmonitor.\nIf the thread already owns the monitor associated with\nobjectref, it reenters the monitor, incrementing its entry\ncount.\nIf another thread already owns the monitor associated with\nobjectref, the thread blocks until the monitor's entry count\nis zero, then tries again to gain ownership.\nIf the entry count of the monitor associated with objectref\nis zero, the thread enters the monitor and sets its entry\ncount to one. The thread is then the owner of the\nmonitor.\nIf the thread already owns the monitor associated with\nobjectref, it reenters the monitor, incrementing its entry\ncount.\nIf another thread already owns the monitor associated with\nobjectref, the thread blocks until the monitor's entry count\nis zero, then tries again to gain ownership."
    },
    {
      "name": "monitorexit",
      "operation": "Exit monitor for object",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "monitorexit",
          "value": 195
        }
      ],
      "stack": "..., objectref \u2192 ...",
      "description": "The objectref must be of type reference.\nThe thread that executes monitorexit must be the owner of the\nmonitor associated with the instance referenced by\nobjectref.\nThe thread decrements the entry count of the monitor associated\nwith objectref. If as a result the value of the entry count is\nzero, the thread exits the monitor and is no longer its\nowner. Other threads that are blocking to enter the monitor are\nallowed to attempt to do so."
    },
    {
      "name": "multianewarray",
      "operation": "Create new multidimensional array",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2",
          "dimensions"
        ]
      ],
      "values": [
        {
          "name": "multianewarray",
          "value": 197
        }
      ],
      "stack": "..., count1, [count2, ...] \u2192 ..., arrayref",
      "description": "The dimensions operand is an unsigned byte\nthat must be greater than or equal to 1. It represents the number\nof dimensions of the array to be created. The operand stack must\ncontain dimensions values. Each such value\nrepresents the number of components in a dimension of the array to\nbe created, must be of type int, and must be\nnon-negative. The count1 is the desired\nlength in the first dimension, count2 in the\nsecond, etc.\nAll of the count values are popped off the\noperand stack. The unsigned indexbyte1 and indexbyte2 are used\nto construct an index into the run-time constant pool of the\ncurrent class (\u00a72.6), where the value of the\nindex is (indexbyte1 << 8) | indexbyte2. The run-time\nconstant pool entry at the index must be a symbolic reference to a\nclass, array, or interface type. The named class, array, or\ninterface type is resolved (\u00a75.4.3.1). The\nresulting entry must be an array class type of dimensionality\ngreater than or equal to dimensions.\nA new multidimensional array of the array type is allocated from\nthe garbage-collected heap. If any count\nvalue is zero, no subsequent dimensions are allocated. The\ncomponents of the array in the first dimension are initialized to\nsubarrays of the type of the second dimension, and so on. The\ncomponents of the last allocated dimension of the array are\ninitialized to the default initial value\n(\u00a72.3, \u00a72.4) for the\nelement type of the array type. A reference arrayref to the new\narray is pushed onto the operand stack."
    },
    {
      "name": "new",
      "operation": "Create new object",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "new",
          "value": 187
        }
      ],
      "stack": "... \u2192 ..., objectref",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a class or\ninterface type. The named class or interface type is resolved\n(\u00a75.4.3.1) and should result in a class\ntype. Memory for a new instance of that class is allocated from\nthe garbage-collected heap, and the instance variables of the new\nobject are initialized to their default initial values\n(\u00a72.3, \u00a72.4). The\nobjectref, a reference to the instance, is pushed onto the operand\nstack.\nOn successful resolution of the class, it is initialized if it has\nnot already been initialized (\u00a75.5)."
    },
    {
      "name": "newarray",
      "operation": "Create new array",
      "formats": [
        [
          "atype"
        ]
      ],
      "values": [
        {
          "name": "newarray",
          "value": 188
        }
      ],
      "stack": "..., count \u2192 ..., arrayref",
      "description": "The count must be of type int. It is popped off the operand\nstack. The count represents the number of elements in the array\nto be created.\nThe atype is a code that indicates the type\nof array to create. It must take one of the following\nvalues:\nA new array whose components are of\ntype atype and of length count is allocated\nfrom the garbage-collected heap. A reference arrayref to this new\narray object is pushed into the operand stack. Each of the\nelements of the new array is initialized to the default initial\nvalue (\u00a72.3, \u00a72.4) for\nthe element type of the array type."
    },
    {
      "name": "nop",
      "operation": "Do nothing",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "nop",
          "value": 0
        }
      ],
      "stack": "No change",
      "description": "Do nothing."
    },
    {
      "name": "pop",
      "operation": "Pop the top operand stack value",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "pop",
          "value": 87
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "Pop the top value from the operand stack.\nThe pop instruction must not be used unless value is a value\nof a category 1 computational type\n(\u00a72.11.1)."
    },
    {
      "name": "pop2",
      "operation": "Pop the top one or two operand stack values",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "pop2",
          "value": 88
        }
      ],
      "stack": "Form 1: ..., value2, value1 \u2192 ... where each of value1 and value2 is a value of a category 1\ncomputational type (\u00a72.11.1). Form 2: ..., value \u2192 ... where value is a value of a category 2 computational type\n(\u00a72.11.1).",
      "description": "Pop the top one or two values from the operand stack."
    },
    {
      "name": "putfield",
      "operation": "Set field in object",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "putfield",
          "value": 181
        }
      ],
      "stack": "..., objectref, value \u2192 ...",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a field\n(\u00a75.1), which gives the name and descriptor\nof the field as well as a symbolic reference to the class in which\nthe field is to be found. The referenced field is resolved\n(\u00a75.4.3.2).\nThe type of a value stored by a putfield instruction must be\ncompatible with the descriptor of the referenced field (\u00a74.3.2). If the field descriptor type is\nboolean, byte, char, short, or int, then the value\nmust be an int. If the field descriptor type is float, long,\nor double, then the value must be a float, long, or\ndouble, respectively. If the field descriptor type is a\nreference type, then the value must be of a type that is\nassignment compatible (JLS \u00a75.2) with the field descriptor\ntype. If the field is final, it must be declared in the current\nclass, and the instruction must occur in an instance\ninitialization method of the current class (\u00a72.9.1).\nThe value and objectref are popped from the operand stack.\nThe objectref must be of type reference but not an array type.\nIf the value is of type int and the field descriptor type is\none of byte, char, short, or boolean, then the int value\nis converted to the field descriptor type as follows.\nIf the field descriptor type is byte, char, or short, then the\nint value is truncated to a value of the field descriptor type,\nvalue'.\nIf the field descriptor type is boolean, then the int value is\nnarrowed by taking the bitwise AND of value and 1, resulting in\nvalue'.\nThe referenced field in objectref is set to value'.\nOtherwise, the referenced field in objectref is set to value."
    },
    {
      "name": "putstatic",
      "operation": "Set static field in class",
      "formats": [
        [
          "indexbyte1",
          "indexbyte2"
        ]
      ],
      "values": [
        {
          "name": "putstatic",
          "value": 179
        }
      ],
      "stack": "..., value \u2192 ...",
      "description": "The unsigned indexbyte1 and indexbyte2 are used to construct\nan index into the run-time constant pool of the current class\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The run-time constant\npool entry at the index must be a symbolic reference to a field\n(\u00a75.1), which gives the name and descriptor\nof the field as well as a symbolic reference to the class or\ninterface in which the field is to be found. The referenced field\nis resolved (\u00a75.4.3.2).\nOn successful resolution of the field, the class or interface that\ndeclared the resolved field is initialized if that class or\ninterface has not already been initialized (\u00a75.5).\nThe type of a value stored by a putstatic instruction must be\ncompatible with the descriptor of the referenced field\n(\u00a74.3.2). If the field descriptor type is\nboolean, byte, char, short, or int, then the value\nmust be an int. If the field descriptor type is float, long,\nor double, then the value must be a float, long, or\ndouble, respectively. If the field descriptor type is a\nreference type, then the value must be of a type that is\nassignment compatible (JLS \u00a75.2) with the field descriptor\ntype. If the field is final, it must be declared in the current\nclass or interface, and the instruction must occur in the class or\ninterface initialization method of the current class or interface\n(\u00a72.9.2).\nThe value is popped from the operand stack.\nIf the value is of type int and the field descriptor type is\none of byte, char, short, or boolean, then the int value\nis converted to the field descriptor type as follows.\nIf the field descriptor type is byte, char, or short, then the\nint value is truncated to a value of the field descriptor type,\nvalue'.\nIf the field descriptor type is boolean, then the int value is\nnarrowed by taking the bitwise AND of value and 1, resulting in\nvalue'.\nThe referenced field in the class or interface is set to value'.\nOtherwise, the referenced field in the class or interface is set to\nvalue."
    },
    {
      "name": "ret",
      "operation": "Return from subroutine",
      "formats": [
        [
          "index"
        ]
      ],
      "values": [
        {
          "name": "ret",
          "value": 169
        }
      ],
      "stack": "No change",
      "description": "The index is an unsigned byte between 0 and 255, inclusive. The\nlocal variable at index in the current frame\n(\u00a72.6) must contain a value of type\nreturnAddress. The contents of the local variable are written\ninto the Java Virtual Machine's pc register, and execution continues\nthere."
    },
    {
      "name": "return",
      "operation": "Return void from method",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "return",
          "value": 177
        }
      ],
      "stack": "... \u2192 [empty]",
      "description": "The current method must have return type void. If the current\nmethod is a synchronized method, the monitor entered or\nreentered on invocation of the method is updated and possibly\nexited as if by execution of a monitorexit instruction\n(\u00a7monitorexit) in the current thread. If\nno exception is thrown, any values on the operand stack of the\ncurrent frame (\u00a72.6) are discarded.\nThe interpreter then returns control to the invoker of the method,\nreinstating the frame of the invoker."
    },
    {
      "name": "saload",
      "operation": "Load short from array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "saload",
          "value": 53
        }
      ],
      "stack": "..., arrayref, index \u2192 ..., value",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type short. The index must be of type\nint. Both arrayref and index are popped from the operand\nstack. The component of the array at index is retrieved and\nsign-extended to an int value. That value is pushed onto the\noperand stack."
    },
    {
      "name": "sastore",
      "operation": "Store into short array",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "sastore",
          "value": 86
        }
      ],
      "stack": "..., arrayref, index, value \u2192 ...",
      "description": "The arrayref must be of type reference and must refer to an array\nwhose components are of type short. Both index and value\nmust be of type int. The arrayref, index, and value are\npopped from the operand stack. The int value is truncated to a\nshort and stored as the component of the array indexed by\nindex."
    },
    {
      "name": "sipush",
      "operation": "Push short",
      "formats": [
        [
          "byte1",
          "byte2"
        ]
      ],
      "values": [
        {
          "name": "sipush",
          "value": 17
        }
      ],
      "stack": "... \u2192 ..., value",
      "description": "The immediate unsigned byte1\nand byte2 values are assembled into an\nintermediate short, where the value of the short is\n(byte1 << 8)\n| byte2. The intermediate value is then\nsign-extended to an int value. That value is pushed onto the\noperand stack."
    },
    {
      "name": "swap",
      "operation": "Swap the top two operand stack values",
      "formats": [
        []
      ],
      "values": [
        {
          "name": "swap",
          "value": 95
        }
      ],
      "stack": "..., value2, value1 \u2192 ..., value1, value2",
      "description": "Swap the top two values on the operand stack.\nThe swap instruction must not be used unless value1 and\nvalue2 are both values of a category 1 computational type\n(\u00a72.11.1)."
    },
    {
      "name": "tableswitch",
      "operation": "Access jump table by index and jump",
      "formats": [
        [
          "<0-3\u00a0byte\u00a0pad>",
          "defaultbyte1",
          "defaultbyte2",
          "defaultbyte3",
          "defaultbyte4",
          "lowbyte1",
          "lowbyte2",
          "lowbyte3",
          "lowbyte4",
          "highbyte1",
          "highbyte2",
          "highbyte3",
          "highbyte4",
          "jump\u00a0offsets..."
        ]
      ],
      "values": [
        {
          "name": "tableswitch",
          "value": 170
        }
      ],
      "stack": "..., index \u2192 ...",
      "description": "A tableswitch is a variable-length instruction. Immediately\nafter the tableswitch opcode, between zero and three bytes must\nact as padding, such that defaultbyte1 begins\nat an address that is a multiple of four bytes from the start of\nthe current method (the opcode of its first\ninstruction). Immediately after the padding are bytes constituting\nthree signed 32-bit values: default,\nlow, and high.\nImmediately following are bytes constituting a series\nof high - low + 1 signed\n32-bit offsets. The value low must be less\nthan or equal to high.\nThe high - low + 1\nsigned 32-bit offsets are treated as a 0-based jump table. Each of\nthese signed 32-bit values is constructed as\n(byte1 << 24) |\n(byte2 << 16) |\n(byte3 << 8)\n| byte4.\nThe index must be of type int and is popped from the operand\nstack. If index is less than low or index\nis greater than high, then a target address\nis calculated by adding default to the\naddress of the opcode of this tableswitch\ninstruction. Otherwise, the offset at position\nindex - low of the jump\ntable is extracted. The target address is calculated by adding\nthat offset to the address of the opcode of this tableswitch\ninstruction. Execution then continues at the target\naddress.\nThe target address that can be calculated from each jump table\noffset, as well as the one that can be calculated\nfrom default, must be the address of an\nopcode of an instruction within the method that contains this\ntableswitch instruction."
    },
    {
      "name": "wide",
      "operation": "Extend local variable index by additional bytes",
      "formats": [
        [
          "<opcode>",
          "indexbyte1",
          "indexbyte2"
        ],
        [
          "iinc",
          "indexbyte1",
          "indexbyte2",
          "constbyte1",
          "constbyte2"
        ]
      ],
      "values": [
        {
          "name": "wide",
          "value": 196
        }
      ],
      "stack": "Same as modified instruction",
      "description": "The wide instruction modifies the behavior of another\ninstruction. It takes one of two formats, depending on the\ninstruction being modified. The first form of the wide\ninstruction modifies one of the instructions iload, fload,\naload, lload, dload, istore, fstore, astore, lstore,\ndstore, or ret (\u00a7iload,\n\u00a7fload,\n\u00a7aload,\n\u00a7lload,\n\u00a7dload,\n\u00a7istore,\n\u00a7fstore,\n\u00a7astore,\n\u00a7lstore,\n\u00a7dstore,\n\u00a7ret). The second form applies only to\nthe iinc instruction (\u00a7iinc).\nIn either case, the wide opcode itself is followed in the\ncompiled code by the opcode of the instruction wide modifies. In\neither form, two unsigned bytes indexbyte1 and indexbyte2\nfollow the modified opcode and are assembled into a 16-bit\nunsigned index to a local variable in the current frame\n(\u00a72.6), where the value of the index is\n(indexbyte1 << 8) | indexbyte2. The calculated index\nmust be an index into the local variable array of the current\nframe. Where the wide instruction modifies an lload, dload,\nlstore, or dstore instruction, the index following the\ncalculated index (index + 1) must also be an index into the local\nvariable array. In the second form, two immediate unsigned bytes\nconstbyte1\nand constbyte2 follow indexbyte1 and\nindexbyte2 in the code stream. Those bytes are also assembled\ninto a signed 16-bit constant, where the constant is\n(constbyte1 << 8)\n| constbyte2.\nThe widened bytecode operates as normal, except for the use of the\nwider index and, in the case of the second form, the larger\nincrement range."
    }
  ]
}